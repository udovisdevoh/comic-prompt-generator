<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Générateur de Prompts BD IA</title>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3, h4 {
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        h3.mode-title {
            border-bottom-style: dashed;
            color: #0056b3;
        }
        h4 { 
            border-bottom-style: solid;
            border-bottom-width: 1px;
            border-color: #007bff;
            padding-bottom: 8px;
            margin-top: 25px;
            font-size: 1.2em;
        }
        label {
            display: block;
            margin-top: 10px;
            font-weight: bold;
        }
        input[type="text"], input[type="number"], select, textarea {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            margin-right: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .button-secondary {
            background-color: #6c757d;
        }
        .button-secondary:hover {
            background-color: #545b62;
        }
        .button-tertiary { 
            background-color: #28a745; 
        }
        .button-tertiary:hover {
            background-color: #1e7e34;
        }
        .step-section, .mode-section {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .page-generation-block { 
            border: 1px solid #ccc;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
            background-color: #fdfdfd;
        }
        .storyboard-page-section { 
            margin-top:15px;
            padding-top:15px;
            border-top: 1px dashed #007bff;
        }
        #toast-notification {
            visibility: hidden; min-width: 250px; background-color: #333; color: #fff; text-align: center;
            border-radius: 4px; padding: 16px; position: fixed; z-index: 1000; left: 50%;
            transform: translateX(-50%); bottom: 30px; font-size: 17px; opacity: 0;
            transition: opacity 0.5s, bottom 0.5s, visibility 0.5s;
        }
        #toast-notification.show { visibility: visible; opacity: 1; bottom: 50px; }
        .hidden { display: none !important; } 
        .mode-selector { margin-bottom: 20px; padding: 10px; background-color: #ddeeff; border-radius: 5px;}
        .mode-selector label { margin-right: 10px; }
        .warning-text { font-size: 0.9em; color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 8px; border-radius: 4px; margin-top: 5px; margin-bottom:10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Générateur de Prompts BD IA</h1>

        <div class="mode-selector">
            <h3>Choisir le mode de génération de texte :</h3>
            <label><input type="radio" name="generationMode" value="stepByStep" checked> Mode par Étapes (inclut Storyboard par page)</label>
            <label><input type="radio" name="generationMode" value="singleBlock"> Mode Monobloc (Texte intégral)</label>
        </div>

        <div class="step-section" id="parametersSection">
            <h2>Paramètres Généraux de l'Oeuvre</h2>
            <label for="presetSelect">Choisir un preset :</label>
            <select id="presetSelect">
                <option value="">-- Manuel --</option>
            </select>
            <label for="nomBd">Nom de la série / type d'oeuvre :</label>
            <input type="text" id="nomBd" value="Mon Gag">
            <label for="totalPages">Pages/Strips au total (base) :</label>
            <input type="number" id="totalPages" value="2">
            <label for="pageVariation">Variation de pages/strips (+/-) :</label>
            <input type="number" id="pageVariation" value="0">
            <label for="panelsPerPage">Cases par page/strip (moyenne) :</label>
            <input type="number" id="panelsPerPage" value="6">
            <label for="bubblesPerPage">Bulles par page/strip (moyenne) :</label>
            <input type="number" id="bubblesPerPage" value="5">
            <label for="wordsPerPage">Mots par page/strip (moyenne) :</label>
            <input type="number" id="wordsPerPage" value="30">
            <label for="yellowBlocksPerPage">Blocs narratifs par page/strip (moyenne) :</label>
            <input type="number" id="yellowBlocksPerPage" value="0">
        </div>

        <div id="stepByStepModeContainer">
            <h3 class="mode-title">Mode par Étapes</h3>
            <div class="step-section">
                <h2>Étape 1 : Définition de l'Oeuvre</h2>
                <button id="generateStep1Prompt">Générer Prompt Étape 1</button>
                <label for="step1PromptOutput">Prompt pour l'IA (Étape 1) :</label>
                <textarea id="step1PromptOutput" readonly></textarea>
                <button id="copyStep1Prompt" class="button-secondary">Copier Prompt Étape 1</button>
                <label for="step1AiResponse">Coller le résultat de l'IA (Titre, Résumé, Personnages, Ton) :</label>
                <textarea id="step1AiResponse"></textarea>
            </div>

            <div class="step-section">
                <h2>Étape 2 : Structure des Pages/Strips</h2>
                <button id="generateStep2Prompt">Générer Prompt Étape 2</button>
                <label for="step2PromptOutput">Prompt pour l'IA (Étape 2) :</label>
                <textarea id="step2PromptOutput" readonly></textarea>
                <button id="copyStep2Prompt" class="button-secondary">Copier Prompt Étape 2</button>
                <label for="step2AiResponse">Coller le résultat de l'IA (Descriptions sommaires) :</label>
                <textarea id="step2AiResponse"></textarea>
            </div>

            <div class="step-section">
                <h2>Étape 3 : Génération Détaillée & Storyboard par Page/Strip</h2>
                <button id="setupStep3Fields">Préparer les champs pour l'Étape 3</button>
                <div id="step3PagePromptsContainer"></div>
            </div>

            <div class="step-section">
                <h2>Étape 4 : Compilation Textuelle Finale (Optionnel)</h2>
                <p>Compile tout le contenu textuel des étapes précédentes.</p>
                <button id="compileAllContent">Compiler Tout le Contenu Textuel</button>
                <label for="finalCompilationOutput">Compilation Textuelle Finale :</label>
                <textarea id="finalCompilationOutput" readonly style="min-height: 300px;"></textarea>
                <button id="copyFinalCompilation" class="button-secondary">Copier la Compilation</button>
            </div>
        </div>

        <div id="singleBlockTextModeContainer" class="mode-section hidden">
            <h3 class="mode-title">Mode Monobloc (Sortie Texte Intégral)</h3>
            <p>Génère un prompt unique pour obtenir toute la description textuelle de l'oeuvre par l'IA.</p>
            <button id="generateSingleBlockTextPrompt">Générer Prompt Monobloc (Texte)</button>
            <label for="singleBlockTextPromptOutput">Prompt Monobloc pour l'IA :</label>
            <textarea id="singleBlockTextPromptOutput" readonly style="min-height: 200px;"></textarea>
            <button id="copySingleBlockTextPrompt" class="button-secondary">Copier Prompt Monobloc</button>
            <hr style="margin: 20px 0;">
            <label for="singleBlockAiTextOutput">Coller la réponse textuelle complète de l'IA ici :</label>
            <textarea id="singleBlockAiTextOutput" style="min-height: 250px;"></textarea>
            
            <div id="monoblocStoryboardConversionSection" class="storyboard-page-section">
                 <h4>Conversion en Storyboard de la Sortie Monobloc</h4>
                 <p class="warning-text"><strong>Attention :</strong> Convertir une sortie monobloc de nombreuses pages/strips en storyboard peut générer un prompt de conversion très long et une sortie HTML/SVG extrêmement volumineuse. L'IA pourrait avoir des difficultés à tout traiter ou tronquer le résultat. Le prompt suivant demandera la conversion de TOUT le texte ci-dessus en un unique document HTML.</p>
                 <button id="generateMonoblocToStoryboardPromptBtn" class="button-tertiary">Générer Prompt Storyboard (depuis sortie monobloc)</button>
                 <label for="monoblocToStoryboardConversionPromptOutput">Prompt Storyboard (depuis sortie monobloc) :</label>
                 <textarea id="monoblocToStoryboardConversionPromptOutput" readonly></textarea>
                 <button id="copyMonoblocToStoryboardConversionPromptBtn" class="button-secondary">Copier Prompt Storyboard</button>
                 <label for="monoblocStoryboardAiHtmlOutput">Coller le code HTML/SVG du storyboard complet ici :</label>
                 <textarea id="monoblocStoryboardAiHtmlOutput" style="font-family: monospace;"></textarea>
            </div>
        </div>
    </div>

    <div id="toast-notification"></div>

    <script>
        const presets = { 
            achiletalon:    { nomBd: "Achille Talon (gag 2p.)",                totalPages: 2,  pageVariation: 0,  panelsPerPage: 12, bubblesPerPage: 18, wordsPerPage: 220, yellowBlocksPerPage: 1 },
            asterix:        { nomBd: "Astérix",                                totalPages: 42, pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 13, wordsPerPage: 116, yellowBlocksPerPage: 1 },
            astroboy:       { nomBd: "Astro Boy (chapitre aventure)",          totalPages: 24, pageVariation: 4,  panelsPerPage: 6,  bubblesPerPage: 7,  wordsPerPage: 80,  yellowBlocksPerPage: 1 }, 
            attackontitan:  { nomBd: "Attack on Titan (chapitre)",             totalPages: 40, pageVariation: 5,  panelsPerPage: 5,  bubblesPerPage: 6,  wordsPerPage: 70,  yellowBlocksPerPage: 1 }, 
            berserk:        { nomBd: "Berserk (chapitre)",                     totalPages: 22, pageVariation: 4,  panelsPerPage: 5,  bubblesPerPage: 5,  wordsPerPage: 60,  yellowBlocksPerPage: 1 }, 
            blakemortimer:  { nomBd: "Blake et Mortimer",                      totalPages: 56, pageVariation: 2,  panelsPerPage: 10, bubblesPerPage: 12, wordsPerPage: 280, yellowBlocksPerPage: 2 },
            bouleetbill:    { nomBd: "Boule et Bill (gag 1p.)",                totalPages: 1,  pageVariation: 0,  panelsPerPage: 6,  bubblesPerPage: 6,  wordsPerPage: 45,  yellowBlocksPerPage: 0 },
            deathnote:      { nomBd: "Death Note (chapitre)",                  totalPages: 19, pageVariation: 1,  panelsPerPage: 7,  bubblesPerPage: 9,  wordsPerPage: 110, yellowBlocksPerPage: 1 }, 
            dragonball:     { nomBd: "Dragon Ball (Goku enfant - Arc ~100p.)",  totalPages: 100,pageVariation: 4,  panelsPerPage: 6,  bubblesPerPage: 7,  wordsPerPage: 80,  yellowBlocksPerPage: 1 },
            dragonballz:    { nomBd: "Dragon Ball Z (Goku adulte - Arc ~100p.)",totalPages: 100,pageVariation: 4,  panelsPerPage: 6,  bubblesPerPage: 7,  wordsPerPage: 75,  yellowBlocksPerPage: 1 },
            drslump:        { nomBd: "Dr. Slump (chapitre gag)",               totalPages: 14, pageVariation: 1,  panelsPerPage: 7,  bubblesPerPage: 8,  wordsPerPage: 90,  yellowBlocksPerPage: 1 }, 
            garfield:       { nomBd: "Garfield (gag-strip)",                   totalPages: 1,  pageVariation: 0,  panelsPerPage: 3,  bubblesPerPage: 3,  wordsPerPage: 20,  yellowBlocksPerPage: 0 }, 
            gastonlagaffe:  { nomBd: "Gaston Lagaffe (gag 1p.)",               totalPages: 1,  pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 9,  wordsPerPage: 60,  yellowBlocksPerPage: 0 },
            iznogoud:       { nomBd: "Iznogoud (1 histoire)",                  totalPages: 10, pageVariation: 2,  panelsPerPage: 9,  bubblesPerPage: 13, wordsPerPage: 115, yellowBlocksPerPage: 1 },
            joebarteam:     { nomBd: "Joe Bar Team (gag 1p.)",                 totalPages: 1,  pageVariation: 0,  panelsPerPage: 8,  bubblesPerPage: 8,  wordsPerPage: 80,  yellowBlocksPerPage: 0 },
            jozettejocko:   { nomBd: "Jo, Zette et Jocko",                     totalPages: 52, pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 12, wordsPerPage: 130, yellowBlocksPerPage: 1 },
            luckyluke:      { nomBd: "Lucky Luke",                             totalPages: 44, pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 13, wordsPerPage: 120, yellowBlocksPerPage: 1 },
            marsupilami:    { nomBd: "Marsupilami (aventure)",                 totalPages: 46, pageVariation: 0,  panelsPerPage: 8,  bubblesPerPage: 9,  wordsPerPage: 90,  yellowBlocksPerPage: 1 },
            naruto:         { nomBd: "Naruto (chapitre)",                      totalPages: 18, pageVariation: 2,  panelsPerPage: 6,  bubblesPerPage: 7,  wordsPerPage: 80,  yellowBlocksPerPage: 1 }, 
            onepiece:       { nomBd: "One Piece (chapitre)",                   totalPages: 17, pageVariation: 2,  panelsPerPage: 6,  bubblesPerPage: 8,  wordsPerPage: 90,  yellowBlocksPerPage: 1 }, 
            oumpahpah:      { nomBd: "Oumpah-Pah (1 histoire)",                totalPages: 30, pageVariation: 2,  panelsPerPage: 9,  bubblesPerPage: 11, wordsPerPage: 110, yellowBlocksPerPage: 1 },
            peanuts:        { nomBd: "Peanuts (gag-strip)",                    totalPages: 1,  pageVariation: 0,  panelsPerPage: 4,  bubblesPerPage: 4,  wordsPerPage: 30,  yellowBlocksPerPage: 0 }, 
            philemon:       { nomBd: "Philémon (aventure onirique)",           totalPages: 44, pageVariation: 2,  panelsPerPage: 7,  bubblesPerPage: 11, wordsPerPage: 110, yellowBlocksPerPage: 1 },
            pierrafeuquebec:{ nomBd: "Les Pierrafeu (BD québécoise)",          totalPages: 12, pageVariation: 2,  panelsPerPage: 6,  bubblesPerPage: 7,  wordsPerPage: 90,  yellowBlocksPerPage: 1 },
            petitspirougag: { nomBd: "Le Petit Spirou (gag)",                  totalPages: 1,  pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 9,  wordsPerPage: 60,  yellowBlocksPerPage: 0 },
            petitspirouhist:{ nomBd: "Le Petit Spirou (hist. 6p.)",            totalPages: 6,  pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 10, wordsPerPage: 70,  yellowBlocksPerPage: 0 },
            quickflupke:    { nomBd: "Quick et Flupke (gag)",                  totalPages: 2,  pageVariation: 0,  panelsPerPage: 6,  bubblesPerPage: 5,  wordsPerPage: 30,  yellowBlocksPerPage: 0 },
            schtroumpfs:    { nomBd: "Les Schtroumpfs (1 histoire)",           totalPages: 29, pageVariation: 10, panelsPerPage: 10, bubblesPerPage: 13, wordsPerPage: 100, yellowBlocksPerPage: 1 },
            simpsonquebec:  { nomBd: "Les Simpson (BD québécoise)",            totalPages: 22, pageVariation: 2,  panelsPerPage: 6,  bubblesPerPage: 8,  wordsPerPage: 110, yellowBlocksPerPage: 1 },
            spirou:         { nomBd: "Spirou et Fantasio",                     totalPages: 58, pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 14, wordsPerPage: 130, yellowBlocksPerPage: 1 },
            spyxfamily:     { nomBd: "Spy x Family (chapitre/mission)",        totalPages: 25, pageVariation: 5,  panelsPerPage: 6,  bubblesPerPage: 8,  wordsPerPage: 90,  yellowBlocksPerPage: 1 }, 
            tintin:         { nomBd: "Tintin",                                 totalPages: 62, pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 13, wordsPerPage: 140, yellowBlocksPerPage: 1 },
            yakari:         { nomBd: "Yakari (aventure jeunesse)",             totalPages: 44, pageVariation: 0,  panelsPerPage: 8,  bubblesPerPage: 9,  wordsPerPage: 80,  yellowBlocksPerPage: 1 },
            yokotsuno:      { nomBd: "Yoko Tsuno",                             totalPages: 44, pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 11, wordsPerPage: 130, yellowBlocksPerPage: 1 }
        };

        const presetSelect = document.getElementById('presetSelect');
        const nomBdInput = document.getElementById('nomBd');
        const totalPagesInput = document.getElementById('totalPages');
        const pageVariationInput = document.getElementById('pageVariation');
        const panelsPerPageInput = document.getElementById('panelsPerPage');
        const bubblesPerPageInput = document.getElementById('bubblesPerPage');
        const wordsPerPageInput = document.getElementById('wordsPerPage');
        const yellowBlocksPerPageInput = document.getElementById('yellowBlocksPerPage');

        const generateStep1PromptBtn = document.getElementById('generateStep1Prompt');
        const step1PromptOutput = document.getElementById('step1PromptOutput');
        const copyStep1PromptBtn = document.getElementById('copyStep1Prompt');
        const step1AiResponse = document.getElementById('step1AiResponse');

        const generateStep2PromptBtn = document.getElementById('generateStep2Prompt');
        const step2PromptOutput = document.getElementById('step2PromptOutput');
        const copyStep2PromptBtn = document.getElementById('copyStep2Prompt');
        const step2AiResponse = document.getElementById('step2AiResponse');
        
        const setupStep3FieldsBtn = document.getElementById('setupStep3Fields');
        const step3PagePromptsContainer = document.getElementById('step3PagePromptsContainer');

        const compileAllContentBtn = document.getElementById('compileAllContent');
        const finalCompilationOutput = document.getElementById('finalCompilationOutput'); 
        const copyFinalCompilationBtn = document.getElementById('copyFinalCompilation');
        
        const toastNotification = document.getElementById('toast-notification');
        let toastTimeout;

        const modeRadios = document.querySelectorAll('input[name="generationMode"]');
        const stepByStepModeContainer = document.getElementById('stepByStepModeContainer');
        const singleBlockTextModeContainer = document.getElementById('singleBlockTextModeContainer'); 

        const generateSingleBlockTextPromptBtn = document.getElementById('generateSingleBlockTextPrompt');
        const singleBlockTextPromptOutput = document.getElementById('singleBlockTextPromptOutput');
        const copySingleBlockTextPromptBtn = document.getElementById('copySingleBlockTextPrompt');
        const singleBlockAiTextOutput = document.getElementById('singleBlockAiTextOutput');
        
        const monoblocStoryboardConversionSection = document.getElementById('monoblocStoryboardConversionSection'); 
        const generateMonoblocToStoryboardPromptBtn = document.getElementById('generateMonoblocToStoryboardPromptBtn'); 
        const monoblocToStoryboardConversionPromptOutput = document.getElementById('monoblocToStoryboardConversionPromptOutput'); 
        const copyMonoblocToStoryboardConversionPromptBtn = document.getElementById('copyMonoblocToStoryboardConversionPromptBtn');
        const monoblocStoryboardAiHtmlOutput = document.getElementById('monoblocStoryboardAiHtmlOutput'); 


        function switchMode(mode) {
            stepByStepModeContainer.classList.add('hidden');
            singleBlockTextModeContainer.classList.add('hidden');
            if (mode === 'stepByStep') {
                stepByStepModeContainer.classList.remove('hidden');
            } else if (mode === 'singleBlock') {
                singleBlockTextModeContainer.classList.remove('hidden');
            }
        }

        modeRadios.forEach(radio => {
            radio.addEventListener('change', function() {
                switchMode(this.value);
            });
        });
        
        function setDefaultParameters() {
            nomBdInput.value = "Mon Gag"; 
            totalPagesInput.value = 2; 
            pageVariationInput.value = 0; 
            panelsPerPageInput.value = 6;
            bubblesPerPageInput.value = 5;
            wordsPerPageInput.value = 30;
            yellowBlocksPerPageInput.value = 0;
             monoblocStoryboardConversionSection.classList.remove('hidden'); // Toujours visible dans ce mode
        }

        function populatePresetDropdown() {
            const sortedPresets = Object.entries(presets)
                .map(([key, value]) => ({ key: key, displayName: value.nomBd }))
                .sort((a, b) => a.displayName.localeCompare(b.displayName, 'fr', { sensitivity: 'base' }));

            while (presetSelect.options.length > 1) {
                presetSelect.remove(1);
            }

            sortedPresets.forEach(presetInfo => {
                const option = document.createElement('option');
                option.value = presetInfo.key;
                option.textContent = presetInfo.displayName;
                presetSelect.appendChild(option);
            });
        }
        
        presetSelect.addEventListener('change', function() {
            const selectedPresetKey = this.value;
            const selectedPreset = presets[selectedPresetKey];
            if (selectedPreset) {
                nomBdInput.value = selectedPreset.nomBd;
                totalPagesInput.value = selectedPreset.totalPages;
                pageVariationInput.value = selectedPreset.pageVariation; 
                panelsPerPageInput.value = selectedPreset.panelsPerPage;
                bubblesPerPageInput.value = selectedPreset.bubblesPerPage;
                wordsPerPageInput.value = selectedPreset.wordsPerPage;
                yellowBlocksPerPageInput.value = selectedPreset.yellowBlocksPerPage;
            } else {
                setDefaultParameters();
            }
            step3PagePromptsContainer.innerHTML = ''; 
            if(selectedPresetKey !== "") { 
                 showToastNotification("Les champs de l'Étape 3 ont été réinitialisés suite au changement de preset/paramètres.");
            }
             monoblocStoryboardConversionSection.classList.remove('hidden'); // S'assurer qu'elle est visible quand les params changent
        });
        
        function showToastNotification(message) {
            if (toastTimeout) clearTimeout(toastTimeout);
            toastNotification.textContent = message;
            toastNotification.className = "show";
            toastTimeout = setTimeout(() => { 
                toastNotification.className = toastNotification.className.replace("show", ""); 
            }, 3000);
        }

        function copyToClipboard(elementIdOrText, isText = false) {
            let textToCopy;
            if (isText) {
                textToCopy = elementIdOrText;
                 if (!textToCopy) { showToastNotification("Rien à copier !"); return; }
            } else {
                const textarea = document.getElementById(elementIdOrText);
                if (!textarea || !textarea.value) { showToastNotification("Rien à copier !"); return; }
                textToCopy = textarea.value;
                textarea.select();
                textarea.setSelectionRange(0, 99999);
            }
            try {
                navigator.clipboard.writeText(textToCopy).then(() => {
                     showToastNotification('Contenu copié dans le presse-papiers !');
                }, () => { document.execCommand('copy'); showToastNotification('Contenu copié (fallback) !'); });
            } catch (err) {
                try { document.execCommand('copy'); showToastNotification('Contenu copié (execCommand fallback) !');}
                catch (e) { showToastNotification('La copie a échoué. Veuillez copier manuellement.'); }
            }
        }
        
        function getTypeOeuvre() {
            const nomDeLaBd = nomBdInput.value.trim();
            const currentTotalPages = parseInt(totalPagesInput.value, 10);
            let typeOeuvre = "d'un album"; 
            if (nomDeLaBd.toLowerCase().includes("gag-strip") || (nomDeLaBd.toLowerCase().includes("gag 1p.") && currentTotalPages === 1 && !nomDeLaBd.toLowerCase().includes("petit spirou")) ) { typeOeuvre = "d'un gag (format strip)"; }
            else if (nomDeLaBd.toLowerCase().includes("gag")) { typeOeuvre = "d'un gag"; } 
            else if (nomDeLaBd.toLowerCase().includes("hist.")) { typeOeuvre = "d'une histoire courte"; } 
            else if (nomDeLaBd.toLowerCase().includes("histoire")) { typeOeuvre = "d'une histoire"; } 
            else if (nomDeLaBd.toLowerCase().includes("aventure jeunesse")) { typeOeuvre = "d'une aventure jeunesse"; }
            else if (nomDeLaBd.toLowerCase().includes("aventure")) { typeOeuvre = "d'une aventure"; }
            else if (nomDeLaBd.toLowerCase().includes("(bd québécoise)")) { typeOeuvre = "d'une bande dessinée (style américain, adaptation québécoise)"; } 
            else if (nomDeLaBd.toLowerCase().includes("(chapitre") || nomDeLaBd.toLowerCase().includes("(arc")) { 
                 if (nomDeLaBd.toLowerCase().includes("arc") || (!isNaN(currentTotalPages) && currentTotalPages > 50)) {
                    typeOeuvre = "d'un arc narratif (type manga)";
                } else {
                    typeOeuvre = "d'un chapitre (type manga)";
                }
            }
            return typeOeuvre;
        }

        function getUnitName() {
            const nomDeLaBd = nomBdInput.value.trim();
            const totalPages = parseInt(totalPagesInput.value, 10);
            return (nomDeLaBd.toLowerCase().includes("gag-strip") || (nomDeLaBd.toLowerCase().includes("gag 1p.") && totalPages === 1 && !nomDeLaBd.toLowerCase().includes("petit spirou")) ) ? "strip" : "page";
        }
        
        function getMangaSpecifics() {
            const nomDeLaBd = nomBdInput.value.trim();
            let typeOeuvre = getTypeOeuvre(); 
            if (typeOeuvre.includes("manga") || nomDeLaBd.toLowerCase().includes("chapitre") || nomDeLaBd.toLowerCase().includes("arc") || ["naruto", "one piece", "attack on titan", "death note", "berserk", "spy x family", "dr. slump", "astro boy", "dragon ball", "dragon ball z"].some(m => nomDeLaBd.toLowerCase().includes(m.replace(/\s/g, '')))) { 
                return "\n    - Pour un manga, inclure des suggestions d'onomatopées (effets sonores) et décrire le dynamisme des cases, surtout pour l'action.";
            }
            return "";
        }

        generateStep1PromptBtn.addEventListener('click', function() {
            const nomDeLaBd = nomBdInput.value.trim() || "[Nom de la BD à définir]";
            let typeOeuvre = getTypeOeuvre();
            step1PromptOutput.value = `Générez-moi le titre ${typeOeuvre} de ${nomDeLaBd}\nainsi qu'un très court résumé de l'intrigue principale (1-2 phrases pour un gag ou strip, 3-5 pour une histoire courte ou un chapitre, potentiellement plus pour un arc narratif ou une aventure complète)\nainsi que la liste des personnages importants et leur rôle\net le ton et le style de l'oeuvre. L'oeuvre doit être originale et ne pas trop ressembler à une oeuvre existante mais respecter le thème de l'univers de ${nomDeLaBd}.`;
        });
        copyStep1PromptBtn.addEventListener('click', () => copyToClipboard('step1PromptOutput'));

        generateStep2PromptBtn.addEventListener('click', function() {
            const titreEtDescription = step1AiResponse.value.trim();
            if (!titreEtDescription) { showToastNotification("Veuillez d'abord coller le résultat de l'IA de l'Étape 1."); return; }
            
            const currentNomBd = nomBdInput.value;
            const totalPages = parseInt(totalPagesInput.value, 10);
            const variation = parseInt(pageVariationInput.value, 10);
            let pageCountDescription = "";
            let unitName = getUnitName();

            if (isNaN(totalPages) || totalPages <=0) { showToastNotification("Nombre de pages de base invalide."); return; }
            if (isNaN(variation) || variation < 0) { showToastNotification("Variation de page invalide."); return; }

            if (variation === 0) {
                pageCountDescription = `${totalPages} ${unitName}${totalPages > 1 ? 's' : ''} au total (nombre fixe).`;
            } else {
                const minPages = Math.max(1, totalPages - variation);
                const maxPages = totalPages + variation;
                pageCountDescription = `Environ ${totalPages} ${unitName}${totalPages > 1 ? 's' : ''} au total. Le nombre final peut varier de ${minPages} à ${maxPages}.`;
            }

            let endingDescription = "une conclusion satisfaisante (par exemple, la fin d'un arc narratif, la résolution d'un combat important, ou un cliffhanger pour le prochain chapitre/la prochaine histoire).";
            if (currentNomBd.toLowerCase().includes("gag") || totalPages <= 2) { 
                endingDescription = `une "punch line" – un dénouement surprenant, très drôle, et d'une nature délicieusement absurde ou inusitée.`;
            }

            const panelsAvg = panelsPerPageInput.value;
            const bubblesAvg = bubblesPerPageInput.value;
            const wordsAvg = wordsPerPageInput.value;
            const yellowBlocksAvg = yellowBlocksPerPageInput.value;

            const prompt = `Considérant cette oeuvre (album/histoire/gag/strip/chapitre manga/arc manga/aventure) suivante:
--- DÉBUT TITRE ET DESCRIPTION ---
${titreEtDescription}
--- FIN TITRE ET DESCRIPTION ---

Générez-moi une description sommaire de chaque ${unitName} (courte description d'un maximum 3 lignes par ${unitName}).
${pageCountDescription}
Nombre de cases par ${unitName} en moyenne, peut varier : ${panelsAvg}.
Nombre de bulles par ${unitName} en moyenne (peut varier) : ${bubblesAvg}.
Nombre de mots par ${unitName} en moyenne (peut varier) : ${wordsAvg}.
Nombre de blocs de texte (narratif/explicatif) par ${unitName} en moyenne (peut varier) : ${yellowBlocksAvg}. (Si 0, cela signifie sans narration textuelle).

Chaque ${unitName} (si plusieurs) doit avoir un effet intriguant à la fin pour inciter le lecteur à lire la prochaine (si applicable) et cette mini-intrigue sera résolue ensuite. Le/La dernier/dernière ${unitName} doit terminer par ${endingDescription}
Pour chaque ${unitName}, spécifiez le nombre de cases, de bulles, le nombre de mots, et le nombre de blocs de texte.
${getMangaSpecifics().replace("\n    - Pour un manga, i", "Pour un manga, n")} `;
            step2PromptOutput.value = prompt;
        });
        copyStep2PromptBtn.addEventListener('click', () => copyToClipboard('step2PromptOutput'));

        setupStep3FieldsBtn.addEventListener('click', function() {
            const totalPages = parseInt(totalPagesInput.value, 10);
            let unitNameCapitalized = getUnitName().charAt(0).toUpperCase() + getUnitName().slice(1);

            if (isNaN(totalPages) || totalPages <= 0) { showToastNotification("Veuillez entrer un nombre de pages (base) valide."); return; }
            step3PagePromptsContainer.innerHTML = ''; 
            for (let i = 1; i <= totalPages; i++) {
                const pageBlock = document.createElement('div');
                pageBlock.classList.add('page-generation-block');
                pageBlock.innerHTML = `
                    <h4>${unitNameCapitalized} ${i}</h4>
                    <button id="generateTextPrompt_page_${i}" data-page="${i}">Générer Prompt Texte Détaillé ${unitNameCapitalized} ${i}</button>
                    <label for="step3PagePromptOutput_${i}">Prompt Texte Détaillé pour ${unitNameCapitalized} ${i} :</label>
                    <textarea id="step3PagePromptOutput_${i}" readonly></textarea>
                    <button id="copyTextPrompt_page_${i}" class="button-secondary" data-page="${i}">Copier Prompt Texte</button>
                    
                    <label for="pageAiDetailedResponse_${i}">Coller la description DÉTAILLÉE Textuelle de la ${unitNameCapitalized.toLowerCase()} ${i} (générée par l'IA) :</label>
                    <textarea id="pageAiDetailedResponse_${i}"></textarea> 
                    
                    <div class="storyboard-page-section">
                        <h5>Storyboard pour ${unitNameCapitalized} ${i}</h5>
                        <button id="generateStoryboardPrompt_page_${i}" data-page="${i}" class="button-tertiary">Générer Prompt Storyboard pour cette ${unitNameCapitalized}</button>
                        <label for="storyboardPromptOutput_page_${i}">Prompt Storyboard pour ${unitNameCapitalized} ${i} :</label>
                        <textarea id="storyboardPromptOutput_page_${i}" readonly></textarea>
                        <button id="copyStoryboardPrompt_page_${i}" class="button-secondary" data-page="${i}">Copier Prompt Storyboard</button>
                        <label for="storyboardAiOutput_page_${i}">Coller le code HTML/SVG pour ${unitNameCapitalized} ${i} ici :</label>
                        <textarea id="storyboardAiOutput_page_${i}" style="font-family: monospace;"></textarea>
                    </div>
                `;
                step3PagePromptsContainer.appendChild(pageBlock);
                
                document.getElementById(`generateTextPrompt_page_${i}`).addEventListener('click', handleGenerateDetailedTextPromptForPage);
                document.getElementById(`copyTextPrompt_page_${i}`).addEventListener('click', (e) => copyToClipboard(`step3PagePromptOutput_${e.target.dataset.page}`));
                
                document.getElementById(`generateStoryboardPrompt_page_${i}`).addEventListener('click', handleGenerateStoryboardPromptForPage);
                document.getElementById(`copyStoryboardPrompt_page_${i}`).addEventListener('click', (e) => copyToClipboard(`storyboardPromptOutput_page_${e.target.dataset.page}`));
            }
            if (totalPages > 0) { showToastNotification(`${totalPages} bloc(s) pour l'Étape 3 ont été générés.`); }
        });

        function handleGenerateDetailedTextPromptForPage(event) {
            const pageNum = parseInt(event.target.dataset.page, 10);
            const titreEtDescriptionBD = step1AiResponse.value.trim();
            const descriptionDeChaquePage = step2AiResponse.value.trim(); 
            let unitName = getUnitName();

            if (!titreEtDescriptionBD) { showToastNotification("Veuillez coller le résultat de l'IA de l'Étape 1."); return; }
            if (!descriptionDeChaquePage) { showToastNotification("Veuillez coller le résultat de l'IA de l'Étape 2."); return; }
            
            let prevPageDescriptionRef = "";
            if (pageNum > 1) {
                const prevPageTextResponseTextarea = document.getElementById(`pageAiDetailedResponse_${pageNum - 1}`); 
                if (prevPageTextResponseTextarea && prevPageTextResponseTextarea.value.trim() !== "") {
                    prevPageDescriptionRef = `\nVoici la description détaillée du/de la ${unitName} précédente comme référence :\n--- DÉBUT DESCRIPTION ${unitName.toUpperCase()} PRÉCÉDENTE ---\n"${prevPageTextResponseTextarea.value.trim()}"\n--- FIN DESCRIPTION ${unitName.toUpperCase()} PRÉCÉDENTE ---`;
                } else { showToastNotification(`Info: La description textuelle détaillée de la ${unitName} ${pageNum - 1} n'a pas été fournie pour référence pour le prompt texte.`); }
            }

            const currentNomBd = nomBdInput.value;
            const totalPagesForGagCheck = parseInt(totalPagesInput.value, 10);
            let endingDescriptionDetail = "une conclusion satisfaisante (par exemple, la fin d'un arc narratif, la résolution d'un combat important, ou un cliffhanger pour le prochain chapitre/la prochaine histoire).";
            if (currentNomBd.toLowerCase().includes("gag") || totalPagesForGagCheck <= 2) {
                endingDescriptionDetail = `une "punch line" mémorable – un dénouement surprenant, très drôle, et d'une nature délicieusement absurde ou inusitée.`;
            }
            
            const prompt = `Considérant cette oeuvre (${getTypeOeuvre().replace("d'un ", "").replace("d'une ", "")}) suivante:
--- DÉBUT TITRE ET DESCRIPTION BD ---
${titreEtDescriptionBD}
--- FIN TITRE ET DESCRIPTION BD ---

Et la description sommaire de chaque ${unitName} (générée à l'étape précédente):
--- DÉBUT DESCRIPTION SOMMAIRE DES ${unitName.toUpperCase()}S ---
${descriptionDeChaquePage}
--- FIN DESCRIPTION SOMMAIRE DES ${unitName.toUpperCase()}S ---

Générez-moi la description détaillée TEXTUELLE du/de la ${unitName} ${pageNum}.${prevPageDescriptionRef}
La description détaillée doit contenir chaque case du/de la ${unitName} avec les dialogues (sauf si c'est un gag muet où les descriptions indiqueront 0 bulles/mots) et une description schématique simple des dessins. ${getMangaSpecifics()}
La description détaillée doit pouvoir servir de prompt pour un générateur d'images par intelligence artificielle.
Assurez-vous de respecter le ton, le style, les personnages définis et la structure du/de la ${unitName} (nombre de cases, etc.) qui ont été établis précédemment pour cette oeuvre.
Si la description sommaire des ${unitName}s (issue de l'étape 2) indique un effet intriguant pour ce(tte) ${unitName} ${pageNum} (et si ce n'est pas le/la dernier/dernière ${unitName} de l'oeuvre et qu'elle a plusieurs ${unitName}s), assurez-vous que la description détaillée du/de la ${unitName} se termine par cet effet.
Si c'est le/la dernier/dernière ${unitName} de l'oeuvre (selon les descriptions de l'étape 2), assurez ${endingDescriptionDetail}`;
            document.getElementById(`step3PagePromptOutput_${pageNum}`).value = prompt; 
            showToastNotification(`Prompt pour texte détaillé de la ${unitName} ${pageNum} généré.`);
        }

        function handleGenerateStoryboardPromptForPage(event, sourceTextareaIdForMonobloc, pageNumForMonoblocStoryboard) { 
            const pageNum = pageNumForMonoblocStoryboard || parseInt(event.target.dataset.page, 10);
            const isMonoblocConversion = !!pageNumForMonoblocStoryboard;

            const detailedTextForPage = document.getElementById(sourceTextareaIdForMonobloc || `pageAiDetailedResponse_${pageNum}`).value.trim();
            const step1Info = step1AiResponse.value.trim();

            if (!detailedTextForPage) {
                showToastNotification(`Veuillez d'abord fournir la description textuelle détaillée pour la ${getUnitName()} ${pageNum}.`);
                return;
            }
            
            const nomDeLaBd = nomBdInput.value.trim() || "[Nom de BD non spécifié]";
            const panelsPerPage = panelsPerPageInput.value; 
            let unitName = getUnitName();
            let typeOeuvre = getTypeOeuvre();
            let mangaSpecificsForStoryboard = getMangaSpecifics();
            
            const titleFromStep1Match = step1Info.match(/TITRE DE L'OEUVRE\s*:\s*([^\n]+)/i);
            let extractedTitle = nomDeLaBd; // Fallback
            if (titleFromStep1Match && titleFromStep1Match[1]) {
                extractedTitle = titleFromStep1Match[1].trim();
            } else if (isMonoblocConversion && detailedTextForPage) {
                // Essayer d'extraire le titre de la PARTIE A du texte monobloc
                const monoblocTitleMatch = detailedTextForPage.match(/### PARTIE A : DÉFINITION GLOBALE DE L'OEUVRE[\s\S]*?1\.\s*TITRE DE L'OEUVRE\s*:\s*([^\n]+)/i);
                if (monoblocTitleMatch && monoblocTitleMatch[1]) {
                    extractedTitle = monoblocTitleMatch[1].trim();
                }
            }


            const storyboardPrompt = `
Vous êtes un assistant expert en création de storyboards VISUELS pour bandes dessinées au format HTML et SVG, à partir de descriptions textuelles détaillées.

TÂCHE : Convertir ${isMonoblocConversion ? `la description textuelle complète de l'oeuvre "${nomDeLaBd}" (type "${typeOeuvre}") fournie ci-dessous, qui peut décrire UNE ou PLUSIEURS ${unitName}s,` : `la description détaillée de la ${unitName} NUMÉRO ${pageNum} de l'oeuvre "${nomDeLaBd}" (type "${typeOeuvre}") fournie ci-dessous`} en un **DOCUMENT HTML COMPLET ET AUTONOME** contenant le storyboard pour ${isMonoblocConversion ? `TOUTES les ${unitName}s décrites` : `cette SEULE ${unitName}`}.

${isMonoblocConversion ? 
`DESCRIPTION COMPLÈTE DE L'OEUVRE À CONVERTIR (contient Titre global, Résumé global, Personnages, Ton, et la description détaillée de chaque ${unitName}) :` : 
`INFORMATIONS GÉNÉRALES SUR L'OEUVRE (issues de l'Étape 1 du processus par étapes, pour contexte et titre global) :`}
--- DÉBUT INFO OEUVRE / TEXTE SOURCE ---
${isMonoblocConversion ? detailedTextForPage : (step1Info || `TITRE DE L'OEUVRE : ${nomDeLaBd}\n[Autres informations de l'Étape 1 non fournies]`)} 
--- FIN INFO OEUVRE / TEXTE SOURCE ---

${isMonoblocConversion ? '' : 
`DESCRIPTION DÉTAILLÉE DE LA ${unitName.toUpperCase()} ${pageNum} À CONVERTIR :
--- DÉBUT DESCRIPTION ${unitName.toUpperCase()} ${pageNum} ---
${detailedTextForPage}
--- FIN DESCRIPTION ${unitName.toUpperCase()} ${pageNum} ---`}

PARAMÈTRES GÉNÉRAUX DE L'OEUVRE (pour contexte, la description détaillée est prioritaire pour le contenu de chaque ${unitName}) :
- Nom de l'oeuvre / Série : ${nomDeLaBd}
- Cases par ${unitName} (moyenne indicative globale, la description détaillée de chaque ${unitName} doit être suivie pour le nombre exact de cases) : ${panelsPerPage}

INSTRUCTIONS POUR LA GÉNÉRATION DU DOCUMENT HTML/SVG :
1.  **Format de Sortie :** Un document HTML5 valide et complet, commençant par \`<!DOCTYPE html>\` et se terminant par \`</html>\`.
2.  **Extraction d'Informations Clés :**
    * Extrayez le **TITRE GÉNÉRAL DE L'OEUVRE** (cherchez "TITRE DE L'OEUVRE :" dans la description fournie). Si non trouvé, utilisez "${extractedTitle}".
    * Pour ${isMonoblocConversion ? `CHAQUE ${unitName.toUpperCase()} décrite dans le texte source (PARTIE B et C)` : `CETTE ${unitName.toUpperCase()} ${pageNum}`}:
        * Déterminez le **Nombre de cases** pour cette ${unitName} en analysant sa description (PARTIE B ou C de la source).
3.  **Structure du Document HTML :**
    * \`<head>\` avec \`<title>Storyboard - [TITRE DE L'OEUVRE] ${isMonoblocConversion ? '' : `- ${unitName.charAt(0).toUpperCase() + unitName.slice(1)} ${pageNum}`}</title>\` et les styles CSS.
    * \`<body>\` avec \`<h1>[TITRE DE L'OEUVRE] ${isMonoblocConversion ? '' : `- ${unitName.charAt(0).toUpperCase() + unitName.slice(1)} ${pageNum}`}</h1>\`.
    * Pour ${isMonoblocConversion ? `CHAQUE ${unitName.toUpperCase()} identifiée`: `la ${unitName.toUpperCase()} unique demandée`} :
        * Un \`<div class="comic-page" id="page_[Numéro_de_la_page_dans_l_oeuvre]_storyboard_content">\`.
        * Dans ce div, le résumé de la ${unitName} (\`<h5>\`) et une \`<div class="panel-grid">\`.
4.  **Structure par Case :**
    * Chaque case décrite devient un \`<div class="panel-container">\`.
    * Titre \`<h6>\` : "[DESCRIPTION DÉTAILLÉE DE LA CASE (DESCRIPTION VISUELLE ETC) SANS LES DIALOGUES]".
    * Élément \`<svg class="panel-svg" viewBox="0 0 300 200" xmlns="http://www.w3.org/2000/svg">\`.
5.  **Contenu SVG Schématique :**
    * INTERPRÉTEZ la "Description Visuelle" et "Dialogues/Texte" de chaque case.
    * Formes SVG SIMPLES. Personnages schématiques.
    * Dialogues/Narration dans bulles/rectangles SVG, chacun avec un sous-élément SVG \`<title>texte COMPLET du dialogue/narration</title>\` pour tooltip.
    * Positionnement logique.
    * ${mangaSpecificsForStoryboard}
6.  **Code Source Brut :** N'ÉCHAPPEZ PAS les caractères HTML (\`<\`, \`>\`).

INSPIREZ-VOUS FORTEMENT DU TEMPLATE HTML/SVG SUIVANT COMME STRUCTURE DE BASE POUR VOTRE SORTIE QUI DOIT ÊTRE EN VRAI HTML, pas avec "&lt;"  :
\`\`\`html
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Storyboard - [TITRE DE L'OEUVRE EXTRAIT]${isMonoblocConversion ? '' : ` - ${unitName.charAt(0).toUpperCase() + unitName.slice(1)} ${pageNum}`}</title>
    <style>
        body { font-family: sans-serif; margin: 10px; background-color: #e9e9e9; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .comic-page { border: 2px solid #999; padding: 15px; background-color: #fff; box-shadow: 3px 3px 5px #ccc; width: 90%; margin: 20px auto; }
        .comic-page-summary { font-style: italic; margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        .panel-grid { display: flex; flex-wrap: wrap; gap: 10px; }
        .panel-container { border: 1px solid #ccc; margin-bottom: 15px; padding: 10px; background-color: #f9f9f9; flex: 1 1 calc(33.333% - 20px); box-sizing: border-box; min-width: 450px; max-width: 500px; display: flex; flex-direction: column;}
        .panel-summary { font-size: 0.9em; color: #333; margin-bottom: 5px; }
        .panel-svg { border: 1px solid black; width: 100%; height: auto; aspect-ratio: 4/3; background-color: white; }
        svg text { font-family: "Comic Sans MS", "Arial Narrow", sans-serif; } 
        .speech-bubble-group title {} 
        .speech-bubble-path { fill: white; stroke: black; stroke-width: 1.5; }
        .speech-bubble-text { text-anchor: middle; dominant-baseline: middle; font-size: 14px; fill: black; }
        .narrative-box-path { fill: #FFFACD; stroke: #F0E68C; stroke-width: 1; }
        .narrative-text { font-size: 15px; font-style: italic; fill: black; }
		h6 { font-weight: normal; font-size: 14px; }
    </style>
</head>
<body>
    <h1>[TITRE DE L'OEUVRE EXTRAIT]${isMonoblocConversion ? ` (Storyboard Complet)` : ` - ${unitName.charAt(0).toUpperCase() + unitName.slice(1)} ${pageNum}`}</h1>
    
    <div class="comic-page" id="page_X_storyboard_content"> <h5>${unitName.charAt(0).toUpperCase() + unitName.slice(1)} X : [DESCRIPTION DE CETTE ${unitName}]</h5>
        <div class="panel-grid">
            <div class="panel-container" id="page_X_panel_Y"> <h6>[DESCRIPTION DÉTAILLÉE DE LA CASE (DESCRIPTION VISUELLE ETC) SANS LES DIALOGUES]</h6>
                <svg class="panel-svg" viewBox="0 0 300 200" xmlns="http://www.w3.org/2000/svg">
                    [Contenu SVG pour cette case. Inclure <title> pour tooltips des bulles/narration.]
                    ${mangaSpecificsForStoryboard}
                </svg>
            </div>
            </div>
    </div>
    </body>
</html>
\`\`\`
${isMonoblocConversion ? `
INSTRUCTION IMPORTANTE CONCERNANT LA LONGUEUR DE LA RÉPONSE (Mode Monobloc vers Storyboard) :
Si le storyboard HTML/SVG complet pour TOUTES les ${unitName}s décrites dans le texte source est trop long pour une seule réponse :
1.  Générez autant de ${unitName}s complètes que possible DANS UN DOCUMENT HTML VALIDE.
2.  Indiquez clairement à la fin de votre réponse jusqu'à quelle ${unitName} le code a été fourni (ex: "Code HTML/SVG fourni jusqu'à la ${unitName} X sur Y.").
3.  Soyez prêt à continuer la génération du code pour les ${unitName}s suivantes si l'utilisateur envoie simplement le message : "Continuez". Vous reprendrez alors exactement où vous vous êtes arrêté, en générant les ${unitName}s suivantes, idéalement en complétant le document HTML (si possible) ou en démarrant un nouveau fragment HTML pour les ${unitName}s restantes.` : ''}
`;
            const outputTextareaId = isMonoblocConversion ? `monoblocToStoryboardConversionPromptOutput` : `storyboardPromptOutput_page_${pageNum}`;
            document.getElementById(outputTextareaId).value = storyboardPrompt.trim();
            showToastNotification(`Prompt Storyboard pour ${unitName} ${pageNum} généré.`);
        }
        
        compileAllContentBtn.addEventListener('click', function() {
            let fullCompilation = [];
            const totalPages = parseInt(totalPagesInput.value, 10); 
            let unitName = getUnitName().toUpperCase();

            const etape1Content = step1AiResponse.value.trim();
            if (etape1Content) { fullCompilation.push("=== ÉTAPE 1 : DÉFINITION DE L'OEUVRE ==="); fullCompilation.push(etape1Content);
            } else { showToastNotification("Contenu de l'Étape 1 manquant pour la compilation."); }

            const etape2Content = step2AiResponse.value.trim();
            if (etape2Content) { fullCompilation.push(`\n\n=== ÉTAPE 2 : STRUCTURE DES ${unitName}S (DESCRIPTIONS SOMMAIRES) ===`); fullCompilation.push(etape2Content);
            } else { showToastNotification("Contenu de l'Étape 2 manquant pour la compilation."); }
            
            if (!isNaN(totalPages) && totalPages > 0) {
                let allPagesDetailCollectedOrMarked = true; 
                let step3Content = [];
                for (let i = 1; i <= totalPages; i++) {
                    const pageDetailTextarea = document.getElementById(`pageAiDetailedResponse_${i}`);
                    if (pageDetailTextarea) { 
                        if (pageDetailTextarea.value.trim()) {
                            step3Content.push(`\n--- ${unitName} ${i} ---`); step3Content.push(pageDetailTextarea.value.trim());
                        } else {
                            step3Content.push(`\n--- ${unitName} ${i} ---`); step3Content.push(`[Description détaillée pour ce(tte) ${unitName.toLowerCase()} non fournie]`);
                            allPagesDetailCollectedOrMarked = false; 
                        }
                    } else { 
                        step3Content.push(`\n--- ${unitName} ${i} ---`); step3Content.push(`[Champs pour ${unitName.toLowerCase()} ${i} non générés/trouvés]`);
                        allPagesDetailCollectedOrMarked = false;
                    }
                }
                if (step3Content.length > 0){ fullCompilation.push(`\n\n=== ÉTAPE 3 : DESCRIPTIONS DÉTAILLÉES DES ${unitName}S ===`); fullCompilation.push(step3Content.join("\n")); 
                } else if (totalPages > 0) { 
                     fullCompilation.push(`\n\n=== ÉTAPE 3 : DESCRIPTIONS DÉTAILLÉES DES ${unitName}S ===`);
                     fullCompilation.push(`[Aucune description détaillée de ${unitName.toLowerCase()} n'a été fournie pour les ${totalPages} ${unitName.toLowerCase()}(s) de base.]`);
                }
                 if (!allPagesDetailCollectedOrMarked && step3Content.length > 0) { 
                    showToastNotification(`Certaines descriptions détaillées de ${unitName.toLowerCase()} de l'Étape 3 sont manquantes ou non générées.`);
                }
            } else { showToastNotification("Nombre de pages (base) non défini ou invalide pour compiler l'Étape 3."); }
            
            finalCompilationOutput.value = fullCompilation.join("\n"); 
            if(fullCompilation.length > 0 && (etape1Content || etape2Content || (!isNaN(totalPages) && totalPages > 0) ) ) {
                showToastNotification("Compilation textuelle terminée !");
            } else { showToastNotification("Rien à compiler pour le moment."); }
        });
        copyFinalCompilationBtn.addEventListener('click', () => {
            if (finalCompilationOutput.value.trim() === "") { showToastNotification("Rien à copier, la compilation est vide."); return; }
            copyToClipboard('finalCompilationOutput');
        });
        
        generateSingleBlockTextPromptBtn.addEventListener('click', function() {
            const nomDeLaBd = nomBdInput.value.trim() || "[À DÉFINIR PAR L'IA]";
            const totalPages = parseInt(totalPagesInput.value, 10);
            const variation = parseInt(pageVariationInput.value, 10);
            const panelsPerPage = panelsPerPageInput.value;
            const bubblesPerPage = bubblesPerPageInput.value;
            const wordsPerPage = wordsPerPageInput.value;
            const yellowBlocksPerPage = yellowBlocksPerPageInput.value;

            if (isNaN(totalPages) || totalPages <= 0) {
                showToastNotification("Veuillez définir un nombre de pages (base) valide pour le prompt unique.");
                return;
            }

            let typeOeuvre = getTypeOeuvre(); 
            let unitName = getUnitName();   

            let pageCountDetails = "";
            if (variation === 0) {
                pageCountDetails = `${totalPages} ${unitName}${totalPages > 1 ? 's' : ''} (nombre fixe).`;
            } else {
                const minPages = Math.max(1, totalPages - variation);
                const maxPages = totalPages + variation;
                pageCountDetails = `environ ${totalPages} ${unitName}${totalPages > 1 ? 's' : ''}, pouvant varier de ${minPages} à ${maxPages}.`;
            }

            let endingType = "une conclusion satisfaisante (par exemple, la fin d'un arc narratif, la résolution d'un combat important, ou un cliffhanger pour le prochain chapitre/la prochaine histoire).";
            if (nomDeLaBd.toLowerCase().includes("gag") || totalPages <= 2) {
                endingType = `une "punch line" – un dénouement surprenant, très drôle, et d'une nature délicieusement absurde ou inusitée.`;
            }
            
            let mangaSpecifics = getMangaSpecifics();

            const globalPrompt = `
Vous êtes un assistant expert en création de scénarios et de storyboards pour bandes dessinées.
Votre tâche est de générer une oeuvre complète de type "${typeOeuvre}" dans l'univers de "${nomDeLaBd}".

PARAMÈTRES GÉNÉRAUX DE L'OEUVRE FOURNIS À TITRE INDICATIF (L'IA DEVRA DÉFINIR LES SPÉCIFICITÉS PAR ${unitName.toUpperCase()} DANS LA PARTIE B ET S'Y TENIR) :
- Longueur de base attendue : ${totalPages} ${unitName}${totalPages > 1 ? 's' : ''}.
- Variation autorisée : +/- ${variation} ${unitName}${totalPages > 1 ? 's' : ''}. (Le nombre total de ${unitName}s de l'oeuvre générée doit se situer dans cette fourchette).
- Cases par ${unitName} (moyenne indicative globale) : ${panelsPerPage}
- Bulles par ${unitName} (moyenne indicative globale) : ${bubblesPerPage}
- Mots par ${unitName} (moyenne indicative globale) : ${wordsPerPage}
- Blocs narratifs/explicatifs par ${unitName} (moyenne indicative globale) : ${yellowBlocksPerPage}

VEUILLEZ FOURNIR LES INFORMATIONS SUIVANTES DANS L'ORDRE ET AVEC LA STRUCTURE DÉTAILLÉE CI-DESSOUS :

### PARTIE A : DÉFINITION GLOBALE DE L'OEUVRE
1.  **TITRE DE L'OEUVRE :**
    [Proposez un titre original et adapté]
2.  **RÉSUMÉ DE L'INTRIGUE PRINCIPALE :**
    (1-2 phrases pour un gag/strip, 3-5 pour une histoire courte ou un chapitre, potentiellement plus pour un arc narratif ou une aventure complète. Décrivez le concept central, les enjeux et la direction générale de l'intrigue.)
3.  **PERSONNAGES IMPORTANTS :**
    (Listez les personnages clés de cette oeuvre spécifique, y compris les nouveaux si pertinent, et décrivez brièvement leur rôle ou leur objectif dans cette intrigue.)
4.  **TON ET STYLE :**
    (Décrivez le ton général (humoristique, aventureux, dramatique, etc.) et le style graphique/narratif à adopter pour cette oeuvre, en respectant l'univers de "${nomDeLaBd}".)
5.  **ORIGINALITÉ ET RESPECT DE L'UNIVERS :**
    L'oeuvre générée doit être une création originale, évitant de reproduire trop fidèlement des oeuvres existantes, tout en restant cohérente avec l'esprit, les thèmes et les personnages de l'univers de "${nomDeLaBd}".

### PARTIE B : STRUCTURE DÉTAILLÉE ET RÉSUMÉS DES ${unitName.toUpperCase()}S
1.  **NOMBRE TOTAL DE ${unitName.toUpperCase()}S EFFECTIVEMENT UTILISÉES DANS VOTRE GÉNÉRATION :**
    [Indiquez ici le nombre exact de ${unitName}s que vous allez décrire ci-dessous, en respectant la variation autorisée autour de ${totalPages} ${unitName}s.]
2.  **POUR CHAQUE ${unitName.toUpperCase()}** (du/de la ${unitName} 1 au/à la ${unitName} [Nombre total de ${unitName}s utilisées]) :

    **${unitName.charAt(0).toUpperCase() + unitName.slice(1)} [Numéro]**
    * **Résumé Sommaire :** (1-3 lignes maximum. Décrivez l'action principale et le contenu essentiel. Assurez un effet intriguant à la fin (sauf la dernière, ou pour un gag en une seule unité) qui donne envie de lire la suite, et dont la mini-intrigue sera résolue ensuite.)
    * **Spécifications pour CETTE UNITÉ (${unitName.toUpperCase()}) :** (Ces valeurs doivent être respectées dans la PARTIE C)
        * Nombre de cases prévues : [Nombre exact]
        * Nombre de bulles prévues (approximatif) : [Nombre]
        * Nombre de mots prévus (approximatif) : [Nombre]
        * Nombre de blocs narratifs/explicatifs prévus : [Nombre]

    *(Rappel : La dernière unité (${unitName}) doit se terminer par ${endingType})*

### PARTIE C : DESCRIPTION DÉTAILLÉE DE CHAQUE ${unitName.toUpperCase()} ET DE CHAQUE CASE
**POUR CHAQUE ${unitName.toUpperCase()}** (décrite dans la PARTIE B, du/de la ${unitName} 1 au/à la ${unitName} [Nombre total de ${unitName}s utilisées]) :

**-------------------- DÉBUT ${unitName.toUpperCase()} [Numéro] --------------------**
*(Rappel du Résumé Sommaire de la ${unitName.toUpperCase()} [Numéro] ici)*

**POUR CHAQUE CASE** (de 1 au nombre de cases défini pour CETTE UNITÉ (${unitName.toUpperCase()}) DANS LA PARTIE B) :

**Case [Numéro de la case] :**
* **Description Visuelle :** (Description schématique simple et claire du dessin : personnages, actions, expressions, décor, cadrage, angles. ${mangaSpecifics})
* **Dialogues/Texte :** (Texte exact des bulles, pensées, ou blocs narratifs DANS cette case. Si muet, indiquer "Aucun dialogue".)

**-------------------- FIN ${unitName.toUpperCase()} [Numéro] --------------------**

NOTES IMPORTANTES POUR VOTRE GÉNÉRATION :
-   **Cohérence et Continuité :** Assurez une parfaite continuité narrative, logique et visuelle.
-   **Respect des Instructions :** Suivez scrupuleusement le ton, le style, les personnages de l'univers "${nomDeLaBd}", ainsi que les paramètres généraux (moyennes indicatives globales) ET SURTOUT les spécifications (nombre de cases, bulles, mots, blocs narratifs) que VOUS AVEZ DÉFINIES pour chaque ${unitName} dans la PARTIE B lors de la génération de la PARTIE C.
-   **Clarté pour Générateur d'Images :** La "Description Visuelle" de chaque case doit être formulée de manière à pouvoir servir de prompt efficace pour un générateur d'images par IA.
-   **Format de Sortie :** Veuillez utiliser la structure de titres et listes (comme "### PARTIE A", "1. TITRE", "**${unitName.charAt(0).toUpperCase() + unitName.slice(1)} [X]**", "**Case [Y] :**") pour faciliter la lecture de votre réponse.

INSTRUCTION IMPORTANTE CONCERNANT LA LONGUEUR DE LA RÉPONSE POUR LA PARTIE C :
La description détaillée de toutes les ${unitName}s (PARTIE C) peut s'avérer très longue, en particulier pour les œuvres comptant de nombreuses ${unitName}s.
Si vous ne parvenez pas à générer l'intégralité de la PARTIE C en une seule réponse en raison de limitations de longueur :
1.  Veuillez générer autant de ${unitName}s complètes que possible dans votre réponse actuelle.
2.  À la fin de votre réponse, veuillez indiquer clairement jusqu'à quelle ${unitName} vous avez fourni la description détaillée (par exemple : "Description détaillée fournie jusqu'à la ${unitName} X sur Y.").
3.  Soyez prêt à continuer la génération des ${unitName}s suivantes si l'utilisateur vous envoie simplement le message : "Continuez". Vous reprendrez alors exactement où vous vous êtes arrêté.
`;
            singleBlockTextPromptOutput.value = globalPrompt.trim();
            showToastNotification("Prompt unique global (texte) généré !");
        });
        copySingleBlockTextPromptBtn.addEventListener('click', () => copyToClipboard('singleBlockTextPromptOutput'));
        
        generateMonoblocToStoryboardPromptBtn.addEventListener('click', function() {
            const singleBlockText = singleBlockAiTextOutput.value.trim();
            if (!singleBlockText) {
                showToastNotification("Veuillez d'abord coller la sortie textuelle complète du Mode Monobloc.");
                return;
            }
            // Appeler la fonction de génération de prompt storyboard, en lui indiquant la source et que c'est pour la "page 1" conceptuelle de ce bloc de texte
            handleGenerateStoryboardPromptForPage(null, 'singleBlockAiTextOutput', 1); 
        });
        copyMonoblocToStoryboardConversionPromptBtn.addEventListener('click', () => copyToClipboard('monoblocToStoryboardConversionPromptOutput'));
        
        document.addEventListener('DOMContentLoaded', function() {
            populatePresetDropdown(); 
            setDefaultParameters(); 
            switchMode('stepByStep'); 
            monoblocStoryboardConversionSection.classList.remove('hidden'); // S'assurer qu'il est visible par défaut dans le mode monobloc
        });

    </script>
</body>
</html>