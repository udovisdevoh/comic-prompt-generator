<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Générateur de Prompts BD IA</title>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3, h4 {
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        h3.mode-title {
            border-bottom-style: dashed;
            color: #0056b3;
        }
        h4 { 
            border-bottom-style: solid;
            border-bottom-width: 1px;
            border-color: #007bff;
            padding-bottom: 8px;
            margin-top: 25px;
            font-size: 1.2em;
        }
        label {
            display: block;
            margin-top: 10px;
            font-weight: bold;
        }
        input[type="text"], input[type="number"], select, textarea {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            margin-right: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .button-secondary {
            background-color: #6c757d;
        }
        .button-secondary:hover {
            background-color: #545b62;
        }
        .button-tertiary { 
            background-color: #28a745; 
        }
        .button-tertiary:hover {
            background-color: #1e7e34;
        }
        .step-section, .mode-section {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .page-generation-block { 
            border: 1px solid #ccc;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
            background-color: #fdfdfd;
        }
        .storyboard-page-section { 
            margin-top:15px;
            padding-top:15px;
            border-top: 1px dashed #007bff;
        }
        #toast-notification {
            visibility: hidden; min-width: 250px; background-color: #333; color: #fff; text-align: center;
            border-radius: 4px; padding: 16px; position: fixed; z-index: 1000; left: 50%;
            transform: translateX(-50%); bottom: 30px; font-size: 17px; opacity: 0;
            transition: opacity 0.5s, bottom 0.5s, visibility 0.5s;
        }
        #toast-notification.show { visibility: visible; opacity: 1; bottom: 50px; }
        .hidden { display: none !important; } 
        .mode-selector { margin-bottom: 20px; padding: 10px; background-color: #ddeeff; border-radius: 5px;}
        .mode-selector label { margin-right: 10px; }
        .warning-text { font-size: 0.9em; color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 8px; border-radius: 4px; margin-top: 5px; margin-bottom:10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Générateur de Prompts BD & Roman IA</h1>

        <div class="mode-selector">
            <h3>Choisir le mode de génération :</h3>
            <label><input type="radio" name="generationMode" value="stepByStep" checked> Mode par Étapes (BD/Manga)</label>
            <label><input type="radio" name="generationMode" value="singleBlockText"> Mode Monobloc (Texte BD/Manga)</label>
            <label><input type="radio" name="generationMode" value="singleBlockRoman"> Mode Monobloc (Format Roman)</label>
        </div>

        <div class="step-section" id="parametersSection">
            <h2>Paramètres Généraux de l'Oeuvre</h2>
            <label for="presetSelect">Choisir un preset (sera adapté pour format roman si besoin) :</label>
            <select id="presetSelect">
                <option value="">-- Manuel --</option>
            </select>
            <label for="nomBd">Nom de la série / type d'oeuvre :</label>
            <input type="text" id="nomBd" value="Mon Oeuvre">
            <label for="totalPages" id="totalPagesLabel">Pages/Strips/Chapitres (base) :</label>
            <input type="number" id="totalPages" value="10">
            <label for="pageVariation" id="pageVariationLabel">Variation (+/-) :</label>
            <input type="number" id="pageVariation" value="0">
            
            <div id="comicSpecificParams">
                <label for="panelsPerPage" id="panelsPerPageLabel">Cases par page/strip (moyenne) :</label>
                <input type="number" id="panelsPerPage" value="9">
                <label for="bubblesPerPage" id="bubblesPerPageLabel">Bulles par page/strip (moyenne) :</label>
                <input type="number" id="bubblesPerPage" value="10">
            </div>
            
            <label for="wordsPerPage" id="wordsPerPageLabel">Mots par page/strip/chapitre (moyenne) :</label>
            <input type="number" id="wordsPerPage" value="150">
            <label for="yellowBlocksPerPage" id="yellowBlocksPerPageLabel">Blocs narratifs / Importance narration (0-2) :</label>
            <input type="number" id="yellowBlocksPerPage" value="1">
        </div>

        <div id="stepByStepModeContainer">
            <h3 class="mode-title">Mode par Étapes (BD/Manga)</h3>
            <div class="step-section">
                <h2>Étape 1 : Définition de l'Oeuvre</h2>
                <button id="generateStep1Prompt">Générer Prompt Étape 1</button>
                <label for="step1PromptOutput">Prompt pour l'IA (Étape 1) :</label>
                <textarea id="step1PromptOutput" readonly></textarea>
                <button id="copyStep1Prompt" class="button-secondary">Copier Prompt Étape 1</button>
                <label for="step1AiResponse">Coller le résultat de l'IA (Titre, Résumé, Personnages, Ton) :</label>
                <textarea id="step1AiResponse"></textarea>
            </div>

            <div class="step-section">
                <h2>Étape 2 : Structure des Pages/Strips</h2>
                <button id="generateStep2Prompt">Générer Prompt Étape 2</button>
                <label for="step2PromptOutput">Prompt pour l'IA (Étape 2) :</label>
                <textarea id="step2PromptOutput" readonly></textarea>
                <button id="copyStep2Prompt" class="button-secondary">Copier Prompt Étape 2</button>
                <label for="step2AiResponse">Coller le résultat de l'IA (Descriptions sommaires) :</label>
                <textarea id="step2AiResponse"></textarea>
            </div>

            <div class="step-section">
                <h2>Étape 3 : Génération Détaillée & Storyboard par Page/Strip</h2>
                <button id="setupStep3Fields">Préparer les champs pour l'Étape 3</button>
                <div id="step3PagePromptsContainer"></div>
            </div>

            <div class="step-section">
                <h2>Étape 4 : Compilation Textuelle Finale (Optionnel)</h2>
                <p>Compile tout le contenu textuel des étapes précédentes.</p>
                <button id="compileAllContent">Compiler Tout le Contenu Textuel</button>
                <label for="finalCompilationOutput">Compilation Textuelle Finale :</label>
                <textarea id="finalCompilationOutput" readonly style="min-height: 300px;"></textarea>
                <button id="copyFinalCompilation" class="button-secondary">Copier la Compilation</button>
            </div>
        </div>

        <div id="singleBlockTextModeContainer" class="mode-section hidden">
            <h3 class="mode-title">Mode Monobloc (Texte intégral - Format BD/Manga)</h3>
            <p>Génère un prompt unique pour obtenir toute la description textuelle de l'oeuvre au format BD/Manga par l'IA.</p>
            <button id="generateSingleBlockTextPrompt">Générer Prompt Monobloc (Texte BD/Manga)</button>
            <label for="singleBlockTextPromptOutput">Prompt Monobloc pour l'IA :</label>
            <textarea id="singleBlockTextPromptOutput" readonly style="min-height: 200px;"></textarea>
            <button id="copySingleBlockTextPrompt" class="button-secondary">Copier Prompt Monobloc</button>
            <hr style="margin: 20px 0;">
            <label for="singleBlockAiTextOutput">Coller la réponse textuelle complète de l'IA ici :</label>
            <textarea id="singleBlockAiTextOutput" style="min-height: 250px;"></textarea>
            
            <div id="monoblocStoryboardConversionSection" class="storyboard-page-section">
                 <h4>Conversion en Storyboard de la Sortie Monobloc (BD/Manga)</h4>
                 <p class="warning-text"><strong>Attention :</strong> Convertir une sortie monobloc de nombreuses pages/strips en storyboard peut générer un prompt de conversion très long et une sortie HTML/SVG extrêmement volumineuse. L'IA pourrait avoir des difficultés à tout traiter ou tronquer le résultat. Le prompt suivant demandera la conversion de TOUT le texte ci-dessus en un unique document HTML.</p>
                 <button id="generateMonoblocToStoryboardPromptBtn" class="button-tertiary">Générer Prompt Storyboard (depuis sortie monobloc)</button>
                 <label for="monoblocToStoryboardConversionPromptOutput">Prompt Storyboard (depuis sortie monobloc) :</label>
                 <textarea id="monoblocToStoryboardConversionPromptOutput" readonly></textarea>
                 <button id="copyMonoblocToStoryboardConversionPromptBtn" class="button-secondary">Copier Prompt Storyboard</button>
                 <label for="monoblocStoryboardAiHtmlOutput">Coller le code HTML/SVG du storyboard ici :</label>
                 <textarea id="monoblocStoryboardAiHtmlOutput" style="font-family: monospace;"></textarea>
            </div>
        </div>
        
        <div id="singleBlockRomanModeContainer" class="mode-section hidden">
            <h3 class="mode-title">Mode Monobloc (Format Roman)</h3>
            <p>Génère un prompt unique pour obtenir une oeuvre narrative complète au format roman par l'IA.</p>
            <button id="generateSingleBlockRomanPromptBtn">Générer Prompt Monobloc (Roman)</button>
            <label for="singleBlockRomanPromptOutput">Prompt Monobloc (Roman) pour l'IA :</label>
            <textarea id="singleBlockRomanPromptOutput" readonly style="min-height: 200px;"></textarea>
            <button id="copySingleBlockRomanPromptBtn" class="button-secondary">Copier Prompt Roman</button>
            <hr style="margin: 20px 0;">
            <label for="singleBlockRomanAiOutput">Coller le texte du roman généré par l'IA ici :</label>
            <textarea id="singleBlockRomanAiOutput" style="min-height: 250px;"></textarea>
        </div>

    </div>

    <div id="toast-notification"></div>

    <script>
        const presets = { 
            achiletalon:    { nomBd: "Achille Talon (gag)",                    totalPages: 2,  pageVariation: 0,  panelsPerPage: 12, bubblesPerPage: 18, wordsPerPage: 220, yellowBlocksPerPage: 1 },
            asterix:        { nomBd: "Astérix",                                totalPages: 42, pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 13, wordsPerPage: 116, yellowBlocksPerPage: 1 },
            astroboy:       { nomBd: "Astro Boy (chapitre aventure)",          totalPages: 24, pageVariation: 4,  panelsPerPage: 6,  bubblesPerPage: 7,  wordsPerPage: 80,  yellowBlocksPerPage: 1 }, 
            attackontitan:  { nomBd: "Attack on Titan (chapitre)",             totalPages: 40, pageVariation: 5,  panelsPerPage: 5,  bubblesPerPage: 6,  wordsPerPage: 70,  yellowBlocksPerPage: 1 }, 
            berserk:        { nomBd: "Berserk (chapitre)",                     totalPages: 22, pageVariation: 4,  panelsPerPage: 5,  bubblesPerPage: 5,  wordsPerPage: 60,  yellowBlocksPerPage: 1 }, 
            blakemortimer:  { nomBd: "Blake et Mortimer",                      totalPages: 56, pageVariation: 2,  panelsPerPage: 10, bubblesPerPage: 12, wordsPerPage: 280, yellowBlocksPerPage: 2 },
            bouleetbill:    { nomBd: "Boule et Bill (gag)",                    totalPages: 1,  pageVariation: 0,  panelsPerPage: 6,  bubblesPerPage: 6,  wordsPerPage: 45,  yellowBlocksPerPage: 0 },
            deathnote:      { nomBd: "Death Note (chapitre)",                  totalPages: 19, pageVariation: 1,  panelsPerPage: 7,  bubblesPerPage: 9,  wordsPerPage: 110, yellowBlocksPerPage: 1 }, 
            dragonball:     { nomBd: "Dragon Ball (Goku enfant)",              totalPages: 100,pageVariation: 4,  panelsPerPage: 6,  bubblesPerPage: 7,  wordsPerPage: 80,  yellowBlocksPerPage: 1 },
            dragonballz:    { nomBd: "Dragon Ball Z (Goku adulte)",            totalPages: 100,pageVariation: 4,  panelsPerPage: 6,  bubblesPerPage: 7,  wordsPerPage: 75,  yellowBlocksPerPage: 1 },
            drslump:        { nomBd: "Dr. Slump (chapitre gag)",               totalPages: 14, pageVariation: 1,  panelsPerPage: 7,  bubblesPerPage: 8,  wordsPerPage: 90,  yellowBlocksPerPage: 1 }, 
            garfield:       { nomBd: "Garfield (gag-strip)",                   totalPages: 1,  pageVariation: 0,  panelsPerPage: 3,  bubblesPerPage: 3,  wordsPerPage: 20,  yellowBlocksPerPage: 0 }, 
            gastonlagaffe:  { nomBd: "Gaston Lagaffe (gag)",                   totalPages: 1,  pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 9,  wordsPerPage: 60,  yellowBlocksPerPage: 0 },
            iznogoud:       { nomBd: "Iznogoud (1 histoire)",                  totalPages: 10, pageVariation: 2,  panelsPerPage: 9,  bubblesPerPage: 13, wordsPerPage: 115, yellowBlocksPerPage: 1 },
            joebarteam:     { nomBd: "Joe Bar Team (gag)",                     totalPages: 1,  pageVariation: 0,  panelsPerPage: 8,  bubblesPerPage: 8,  wordsPerPage: 80,  yellowBlocksPerPage: 0 },
            jozettejocko:   { nomBd: "Jo, Zette et Jocko",                     totalPages: 52, pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 12, wordsPerPage: 130, yellowBlocksPerPage: 1 },
            luckyluke:      { nomBd: "Lucky Luke",                             totalPages: 44, pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 13, wordsPerPage: 120, yellowBlocksPerPage: 1 },
            marsupilami:    { nomBd: "Marsupilami (aventure)",                 totalPages: 46, pageVariation: 0,  panelsPerPage: 8,  bubblesPerPage: 9,  wordsPerPage: 90,  yellowBlocksPerPage: 1 },
            naruto:         { nomBd: "Naruto (chapitre)",                      totalPages: 18, pageVariation: 2,  panelsPerPage: 6,  bubblesPerPage: 7,  wordsPerPage: 80,  yellowBlocksPerPage: 1 }, 
            onepiece:       { nomBd: "One Piece (chapitre)",                   totalPages: 17, pageVariation: 2,  panelsPerPage: 6,  bubblesPerPage: 8,  wordsPerPage: 90,  yellowBlocksPerPage: 1 }, 
            oumpahpah:      { nomBd: "Oumpah-Pah",                             totalPages: 30, pageVariation: 2,  panelsPerPage: 9,  bubblesPerPage: 11, wordsPerPage: 110, yellowBlocksPerPage: 1 },
            peanuts:        { nomBd: "Peanuts (gag-strip)",                    totalPages: 1,  pageVariation: 0,  panelsPerPage: 4,  bubblesPerPage: 4,  wordsPerPage: 30,  yellowBlocksPerPage: 0 }, 
            philemon:       { nomBd: "Philémon (aventure onirique)",           totalPages: 44, pageVariation: 2,  panelsPerPage: 7,  bubblesPerPage: 11, wordsPerPage: 110, yellowBlocksPerPage: 1 },
            pierrafeuquebec:{ nomBd: "Les Pierrafeu (BD québécoise)",          totalPages: 12, pageVariation: 2,  panelsPerPage: 6,  bubblesPerPage: 7,  wordsPerPage: 90,  yellowBlocksPerPage: 1 },
            petitspirougag: { nomBd: "Le Petit Spirou (gag)",                  totalPages: 1,  pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 9,  wordsPerPage: 60,  yellowBlocksPerPage: 0 },
            petitspirouhist:{ nomBd: "Le Petit Spirou (hist)",                 totalPages: 6,  pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 10, wordsPerPage: 70,  yellowBlocksPerPage: 0 },
            quickflupke:    { nomBd: "Quick et Flupke (gag)",                  totalPages: 2,  pageVariation: 0,  panelsPerPage: 6,  bubblesPerPage: 5,  wordsPerPage: 30,  yellowBlocksPerPage: 0 },
            schtroumpfs:    { nomBd: "Les Schtroumpfs",                        totalPages: 29, pageVariation: 10, panelsPerPage: 10, bubblesPerPage: 13, wordsPerPage: 100, yellowBlocksPerPage: 1 },
            simpsonquebec:  { nomBd: "Les Simpson (BD québécoise)",            totalPages: 22, pageVariation: 2,  panelsPerPage: 6,  bubblesPerPage: 8,  wordsPerPage: 110, yellowBlocksPerPage: 1 },
            spirou:         { nomBd: "Spirou et Fantasio",                     totalPages: 58, pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 14, wordsPerPage: 130, yellowBlocksPerPage: 1 },
            spyxfamily:     { nomBd: "Spy x Family (chapitre/mission)",        totalPages: 25, pageVariation: 5,  panelsPerPage: 6,  bubblesPerPage: 8,  wordsPerPage: 90,  yellowBlocksPerPage: 1 }, 
            tintin:         { nomBd: "Tintin",                                 totalPages: 62, pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 13, wordsPerPage: 140, yellowBlocksPerPage: 1 },
            yakari:         { nomBd: "Yakari",                                 totalPages: 44, pageVariation: 0,  panelsPerPage: 8,  bubblesPerPage: 9,  wordsPerPage: 80,  yellowBlocksPerPage: 1 },
            yokotsuno:      { nomBd: "Yoko Tsuno",                             totalPages: 44, pageVariation: 0,  panelsPerPage: 9,  bubblesPerPage: 11, wordsPerPage: 130, yellowBlocksPerPage: 1 }
        };

        const presetSelect = document.getElementById('presetSelect');
        const nomBdInput = document.getElementById('nomBd');
        const totalPagesInput = document.getElementById('totalPages');
        const pageVariationInput = document.getElementById('pageVariation');
        const panelsPerPageInput = document.getElementById('panelsPerPage');
        const bubblesPerPageInput = document.getElementById('bubblesPerPage');
        const wordsPerPageInput = document.getElementById('wordsPerPage');
        const yellowBlocksPerPageInput = document.getElementById('yellowBlocksPerPage');
        // Labels des paramètres généraux
        const totalPagesLabel = document.getElementById('totalPagesLabel');
        const pageVariationLabel = document.getElementById('pageVariationLabel');
        const panelsPerPageLabel = document.getElementById('panelsPerPageLabel');
        const bubblesPerPageLabel = document.getElementById('bubblesPerPageLabel');
        const wordsPerPageLabel = document.getElementById('wordsPerPageLabel');
        const yellowBlocksLabel = document.getElementById('yellowBlocksPerPageLabel');
        const comicSpecificParamsDiv = document.getElementById('comicSpecificParams');


        // Step-by-step mode elements
        const generateStep1PromptBtn = document.getElementById('generateStep1Prompt');
        const step1PromptOutput = document.getElementById('step1PromptOutput');
        const copyStep1PromptBtn = document.getElementById('copyStep1Prompt');
        const step1AiResponse = document.getElementById('step1AiResponse');
        const generateStep2PromptBtn = document.getElementById('generateStep2Prompt');
        const step2PromptOutput = document.getElementById('step2PromptOutput');
        const copyStep2PromptBtn = document.getElementById('copyStep2Prompt');
        const step2AiResponse = document.getElementById('step2AiResponse');
        const setupStep3FieldsBtn = document.getElementById('setupStep3Fields');
        const step3PagePromptsContainer = document.getElementById('step3PagePromptsContainer');
        const compileAllContentBtn = document.getElementById('compileAllContent');
        const finalCompilationOutput = document.getElementById('finalCompilationOutput'); 
        const copyFinalCompilationBtn = document.getElementById('copyFinalCompilation');
        
        const toastNotification = document.getElementById('toast-notification');
        let toastTimeout;

        // Mode Management Elements
        const modeRadios = document.querySelectorAll('input[name="generationMode"]');
        const stepByStepModeContainer = document.getElementById('stepByStepModeContainer');
        const singleBlockTextModeContainer = document.getElementById('singleBlockTextModeContainer'); 
        const singleBlockRomanModeContainer = document.getElementById('singleBlockRomanModeContainer'); 

        // Mode Monobloc (Texte BD/Manga) Elements
        const generateSingleBlockTextPromptBtn = document.getElementById('generateSingleBlockTextPrompt');
        const singleBlockTextPromptOutput = document.getElementById('singleBlockTextPromptOutput');
        const copySingleBlockTextPromptBtn = document.getElementById('copySingleBlockTextPrompt');
        const singleBlockAiTextOutput = document.getElementById('singleBlockAiTextOutput');
        
        const monoblocStoryboardConversionSection = document.getElementById('monoblocStoryboardConversionSection'); 
        const generateMonoblocToStoryboardPromptBtn = document.getElementById('generateMonoblocToStoryboardPromptBtn'); 
        const monoblocToStoryboardConversionPromptOutput = document.getElementById('monoblocToStoryboardConversionPromptOutput'); 
        const copyMonoblocToStoryboardConversionPromptBtn = document.getElementById('copyMonoblocToStoryboardConversionPromptBtn');
        const monoblocStoryboardAiHtmlOutput = document.getElementById('monoblocStoryboardAiHtmlOutput'); 

        // Mode Monobloc (Roman) Elements
        const generateSingleBlockRomanPromptBtn = document.getElementById('generateSingleBlockRomanPromptBtn');
        const singleBlockRomanPromptOutput = document.getElementById('singleBlockRomanPromptOutput');
        const copySingleBlockRomanPromptBtn = document.getElementById('copySingleBlockRomanPromptBtn');
        const singleBlockRomanAiOutput = document.getElementById('singleBlockRomanAiOutput');


        function switchMode(mode) {
            stepByStepModeContainer.classList.add('hidden');
            singleBlockTextModeContainer.classList.add('hidden');
            singleBlockRomanModeContainer.classList.add('hidden'); 
            
            const comicParams = document.getElementById('comicSpecificParams'); // Récupérer l'élément ici
            const totalPagesLabel = document.getElementById('totalPagesLabel');
            const pageVariationLabel = document.getElementById('pageVariationLabel');
            const panelsPerPageLabel = document.getElementById('panelsPerPageLabel');
            const bubblesPerPageLabel = document.getElementById('bubblesPerPageLabel');
            const wordsPerPageLabel = document.getElementById('wordsPerPageLabel');
            const yellowBlocksLabel = document.getElementById('yellowBlocksPerPageLabel');

            if (mode === 'stepByStep') {
                stepByStepModeContainer.classList.remove('hidden');
                comicParams.classList.remove('hidden');
                totalPagesLabel.textContent = "Pages/Strips au total (base) :";
                pageVariationLabel.textContent = "Variation de pages/strips (+/-) :";
                panelsPerPageLabel.textContent = "Cases par page/strip (moyenne) :";
                bubblesPerPageLabel.textContent = "Bulles par page/strip (moyenne) :";
                wordsPerPageLabel.textContent = "Mots par page/strip (moyenne) :";
                yellowBlocksLabel.textContent = "Blocs narratifs par page/strip (moyenne) :";
            } else if (mode === 'singleBlockText') { 
                singleBlockTextModeContainer.classList.remove('hidden');
                comicParams.classList.remove('hidden');
                totalPagesLabel.textContent = "Pages/Strips au total (base) :";
                pageVariationLabel.textContent = "Variation de pages/strips (+/-) :";
                panelsPerPageLabel.textContent = "Cases par page/strip (moyenne) :";
                bubblesPerPageLabel.textContent = "Bulles par page/strip (moyenne) :";
                wordsPerPageLabel.textContent = "Mots par page/strip (moyenne) :";
                yellowBlocksLabel.textContent = "Blocs narratifs par page/strip (moyenne) :";
            } else if (mode === 'singleBlockRoman') {
                singleBlockRomanModeContainer.classList.remove('hidden');
                comicParams.classList.add('hidden'); 
                totalPagesLabel.textContent = "Chapitres/Sections au total (base) :";
                pageVariationLabel.textContent = "Variation Chapitres/Sections (+/-) :";
                wordsPerPageLabel.textContent = "Mots par Chapitre/Section (moyenne) :";
                yellowBlocksLabel.textContent = "Importance de la Narration (0=peu, 1=équilibré, 2=beaucoup) :";
            }
        }

        modeRadios.forEach(radio => {
            radio.addEventListener('change', function() {
                switchMode(this.value);
            });
        });
        
        function setDefaultParameters() {
            nomBdInput.value = "Mon Oeuvre"; 
            totalPagesInput.value = 10; 
            pageVariationInput.value = 0; 
            panelsPerPageInput.value = 9; 
            bubblesPerPageInput.value = 10;
            wordsPerPageInput.value = 150;
            yellowBlocksPerPageInput.value = 1;
            monoblocStoryboardConversionSection.classList.remove('hidden'); 
        }

        function populatePresetDropdown() {
            const sortedPresets = Object.entries(presets)
                .map(([key, value]) => ({ key: key, displayName: value.nomBd }))
                .sort((a, b) => a.displayName.localeCompare(b.displayName, 'fr', { sensitivity: 'base' }));

            while (presetSelect.options.length > 1) {
                presetSelect.remove(1);
            }

            sortedPresets.forEach(presetInfo => {
                const option = document.createElement('option');
                option.value = presetInfo.key;
                option.textContent = presetInfo.displayName;
                presetSelect.appendChild(option);
            });
        }
        
        presetSelect.addEventListener('change', function() {
            const selectedPresetKey = this.value;
            const selectedPreset = presets[selectedPresetKey];
            if (selectedPreset) {
                nomBdInput.value = selectedPreset.nomBd;
                totalPagesInput.value = selectedPreset.totalPages;
                pageVariationInput.value = selectedPreset.pageVariation; 
                panelsPerPageInput.value = selectedPreset.panelsPerPage;
                bubblesPerPageInput.value = selectedPreset.bubblesPerPage;
                wordsPerPageInput.value = selectedPreset.wordsPerPage;
                yellowBlocksPerPageInput.value = selectedPreset.yellowBlocksPerPage;
            } else {
                setDefaultParameters();
            }
            step3PagePromptsContainer.innerHTML = ''; 
            if(selectedPresetKey !== "") { 
                 showToastNotification("Les champs de l'Étape 3 ont été réinitialisés suite au changement de preset/paramètres.");
            }
             monoblocStoryboardConversionSection.classList.remove('hidden'); 
        });
        
        function showToastNotification(message) {
            if (toastTimeout) clearTimeout(toastTimeout);
            toastNotification.textContent = message;
            toastNotification.className = "show";
            toastTimeout = setTimeout(() => { 
                toastNotification.className = toastNotification.className.replace("show", ""); 
            }, 3000);
        }

        function copyToClipboard(elementIdOrText, isText = false) {
            let textToCopy;
            if (isText) {
                textToCopy = elementIdOrText;
                 if (!textToCopy) { showToastNotification("Rien à copier !"); return; }
            } else {
                const textarea = document.getElementById(elementIdOrText);
                if (!textarea || !textarea.value) { showToastNotification("Rien à copier !"); return; }
                textToCopy = textarea.value;
                textarea.select();
                textarea.setSelectionRange(0, 99999);
            }
            try {
                navigator.clipboard.writeText(textToCopy).then(() => {
                     showToastNotification('Contenu copié dans le presse-papiers !');
                }, () => { document.execCommand('copy'); showToastNotification('Contenu copié (fallback) !'); });
            } catch (err) {
                try { document.execCommand('copy'); showToastNotification('Contenu copié (execCommand fallback) !');}
                catch (e) { showToastNotification('La copie a échoué. Veuillez copier manuellement.'); }
            }
        }
        
        function getTypeOeuvre(isRomanMode = false) {
            const nomDeLaBd = nomBdInput.value.trim();
            const currentTotalPages = parseInt(totalPagesInput.value, 10);
            
            if(isRomanMode) return "d'un roman (ou d'une nouvelle)";

            let typeOeuvre = "d'un album"; 
            if (nomDeLaBd.toLowerCase().includes("gag-strip") || (nomDeLaBd.toLowerCase().includes("gag 1p.") && currentTotalPages === 1 && !nomDeLaBd.toLowerCase().includes("petit spirou")) ) { typeOeuvre = "d'un gag (format strip)"; }
            else if (nomDeLaBd.toLowerCase().includes("gag")) { typeOeuvre = "d'un gag"; } 
            else if (nomDeLaBd.toLowerCase().includes("hist.")) { typeOeuvre = "d'une histoire courte"; } 
            else if (nomDeLaBd.toLowerCase().includes("histoire")) { typeOeuvre = "d'une histoire"; } 
            else if (nomDeLaBd.toLowerCase().includes("aventure jeunesse")) { typeOeuvre = "d'une aventure jeunesse"; }
            else if (nomDeLaBd.toLowerCase().includes("aventure")) { typeOeuvre = "d'une aventure"; }
            else if (nomDeLaBd.toLowerCase().includes("(bd québécoise)")) { typeOeuvre = "d'une bande dessinée (style américain, adaptation québécoise)"; } 
            else if (nomDeLaBd.toLowerCase().includes("(chapitre") || nomDeLaBd.toLowerCase().includes("(arc")) { 
                 if (nomDeLaBd.toLowerCase().includes("arc") || (!isNaN(currentTotalPages) && currentTotalPages > 50)) {
                    typeOeuvre = "d'un arc narratif (type manga)";
                } else {
                    typeOeuvre = "d'un chapitre (type manga)";
                }
            }
            return typeOeuvre;
        }

        function getUnitName(isRomanMode = false) {
            if(isRomanMode) return "chapitre";

            const nomDeLaBd = nomBdInput.value.trim();
            const totalPages = parseInt(totalPagesInput.value, 10);
            return (nomDeLaBd.toLowerCase().includes("gag-strip") || (nomDeLaBd.toLowerCase().includes("gag 1p.") && totalPages === 1 && !nomDeLaBd.toLowerCase().includes("petit spirou")) ) ? "strip" : "page";
        }
        
        function getMangaSpecifics(isRomanMode = false) {
            if(isRomanMode) return ""; 

            const nomDeLaBd = nomBdInput.value.trim();
            let typeOeuvre = getTypeOeuvre(); 
            if (typeOeuvre.includes("manga") || nomDeLaBd.toLowerCase().includes("chapitre") || nomDeLaBd.toLowerCase().includes("arc") || ["naruto", "one piece", "attack on titan", "death note", "berserk", "spy x family", "dr. slump", "astro boy", "dragon ball", "dragon ball z"].some(m => nomDeLaBd.toLowerCase().includes(m.replace(/\s/g, '')))) { 
                return "\n    - Pour un manga, inclure des suggestions d'onomatopées (effets sonores) et décrire le dynamisme des cases, surtout pour l'action.";
            }
            return "";
        }

        generateStep1PromptBtn.addEventListener('click', function() {
            const nomDeLaBd = nomBdInput.value.trim() || "[Nom de la BD à définir]";
            let typeOeuvre = getTypeOeuvre(document.querySelector('input[name="generationMode"]:checked').value === 'singleBlockRoman');
            step1PromptOutput.value = `Générez-moi le titre ${typeOeuvre} de ${nomDeLaBd}\nainsi qu'un très court résumé de l'intrigue principale (1-2 phrases pour un gag ou strip, 3-5 pour une histoire courte ou un chapitre, potentiellement plus pour un arc narratif ou une aventure complète)\nainsi que la liste des personnages importants et leur rôle\net le ton et le style de l'oeuvre. L'oeuvre doit être originale et ne pas trop ressembler à une oeuvre existante (ni à un titre existant de l'oeuvre, le titre doit être démarqué des titres existants) mais respecter le thème de l'univers de ${nomDeLaBd}.`;
        });
        copyStep1PromptBtn.addEventListener('click', () => copyToClipboard('step1PromptOutput'));

        generateStep2PromptBtn.addEventListener('click', function() {
            const titreEtDescription = step1AiResponse.value.trim();
            if (!titreEtDescription) { showToastNotification("Veuillez d'abord coller le résultat de l'IA de l'Étape 1."); return; }
            
            const currentNomBd = nomBdInput.value;
            const totalPages = parseInt(totalPagesInput.value, 10);
            const variation = parseInt(pageVariationInput.value, 10);
            let pageCountDescription = "";
            let unitName = getUnitName();

            if (isNaN(totalPages) || totalPages <=0) { showToastNotification("Nombre de pages de base invalide."); return; }
            if (isNaN(variation) || variation < 0) { showToastNotification("Variation de page invalide."); return; }

            if (variation === 0) {
                pageCountDescription = `${totalPages} ${unitName}${totalPages > 1 ? 's' : ''} au total (nombre fixe).`;
            } else {
                const minPages = Math.max(1, totalPages - variation);
                const maxPages = totalPages + variation;
                pageCountDescription = `Environ ${totalPages} ${unitName}${totalPages > 1 ? 's' : ''} au total. Le nombre final peut varier de ${minPages} à ${maxPages}.`;
            }

            let endingDescription = "une conclusion satisfaisante (par exemple, la fin d'un arc narratif, la résolution d'un combat important, ou un cliffhanger pour le prochain chapitre/la prochaine histoire).";
            if (currentNomBd.toLowerCase().includes("gag") || totalPages <= 2) { 
                endingDescription = `une "punch line" – un dénouement surprenant (dernière case seulement), très drôle, et d'une nature délicieusement absurde ou inusitée.`;
            }

            const panelsAvg = panelsPerPageInput.value;
            const bubblesAvg = bubblesPerPageInput.value;
            const wordsAvg = wordsPerPageInput.value;
            const yellowBlocksAvg = yellowBlocksPerPageInput.value;

            const prompt = `Considérant cette oeuvre (album/histoire/gag/strip/chapitre manga/arc manga/aventure) suivante:
--- DÉBUT TITRE ET DESCRIPTION ---
${titreEtDescription}
--- FIN TITRE ET DESCRIPTION ---

Générez-moi une description sommaire de chaque ${unitName} (courte description d'un maximum 3 lignes par ${unitName}).
${pageCountDescription}
Nombre de cases par ${unitName} en moyenne, peut varier : ${panelsAvg}.
Nombre de bulles par ${unitName} en moyenne (peut varier) : ${bubblesAvg}.
Nombre de mots par ${unitName} en moyenne (peut varier) : ${wordsAvg}.
Nombre de blocs de texte (narratif/explicatif) par ${unitName} en moyenne (peut varier) : ${yellowBlocksAvg}. (Si 0, cela signifie sans narration textuelle).

Chaque ${unitName} (si plusieurs) doit avoir un effet intriguant à la fin pour inciter le lecteur à lire la prochaine (si applicable) et cette mini-intrigue sera résolue ensuite. Le/La dernier/dernière ${unitName} doit terminer par ${endingDescription}
Pour chaque ${unitName}, spécifiez le nombre de cases, de bulles, le nombre de mots, et le nombre de blocs de texte.
${getMangaSpecifics().replace("\n    - Pour un manga, i", "Pour un manga, n")} `;
            step2PromptOutput.value = prompt;
        });
        copyStep2PromptBtn.addEventListener('click', () => copyToClipboard('step2PromptOutput'));

        setupStep3FieldsBtn.addEventListener('click', function() {
            const totalPages = parseInt(totalPagesInput.value, 10);
            let unitNameCapitalized = getUnitName().charAt(0).toUpperCase() + getUnitName().slice(1);

            if (isNaN(totalPages) || totalPages <= 0) { showToastNotification("Veuillez entrer un nombre de pages (base) valide."); return; }
            step3PagePromptsContainer.innerHTML = ''; 
            for (let i = 1; i <= totalPages; i++) {
                const pageBlock = document.createElement('div');
                pageBlock.classList.add('page-generation-block');
                pageBlock.innerHTML = `
                    <h4>${unitNameCapitalized} ${i}</h4>
                    <button id="generateTextPrompt_page_${i}" data-page="${i}">Générer Prompt Texte Détaillé ${unitNameCapitalized} ${i}</button>
                    <label for="step3PagePromptOutput_${i}">Prompt Texte Détaillé pour ${unitNameCapitalized} ${i} :</label>
                    <textarea id="step3PagePromptOutput_${i}" readonly></textarea>
                    <button id="copyTextPrompt_page_${i}" class="button-secondary" data-page="${i}">Copier Prompt Texte</button>
                    
                    <label for="pageAiDetailedResponse_${i}">Coller la description DÉTAILLÉE Textuelle de la ${unitNameCapitalized.toLowerCase()} ${i} (générée par l'IA) :</label>
                    <textarea id="pageAiDetailedResponse_${i}"></textarea> 
                    
                    <div class="storyboard-page-section">
                        <h5>Storyboard pour ${unitNameCapitalized} ${i}</h5>
                        <button id="generateStoryboardPrompt_page_${i}" data-page="${i}" class="button-tertiary">Générer Prompt Storyboard pour cette ${unitNameCapitalized}</button>
                        <label for="storyboardPromptOutput_page_${i}">Prompt Storyboard pour ${unitNameCapitalized} ${i} :</label>
                        <textarea id="storyboardPromptOutput_page_${i}" readonly></textarea>
                        <button id="copyStoryboardPrompt_page_${i}" class="button-secondary" data-page="${i}">Copier Prompt Storyboard</button>
                        <label for="storyboardAiOutput_page_${i}">Coller le code HTML/SVG pour ${unitNameCapitalized} ${i} ici :</label>
                        <textarea id="storyboardAiOutput_page_${i}" style="font-family: monospace;"></textarea>
                    </div>
                `;
                step3PagePromptsContainer.appendChild(pageBlock);
                
                document.getElementById(`generateTextPrompt_page_${i}`).addEventListener('click', handleGenerateDetailedTextPromptForPage);
                document.getElementById(`copyTextPrompt_page_${i}`).addEventListener('click', (e) => copyToClipboard(`step3PagePromptOutput_${e.target.dataset.page}`));
                
                document.getElementById(`generateStoryboardPrompt_page_${i}`).addEventListener('click', handleGenerateStoryboardPromptForPage);
                document.getElementById(`copyStoryboardPrompt_page_${i}`).addEventListener('click', (e) => copyToClipboard(`storyboardPromptOutput_page_${e.target.dataset.page}`));
            }
            if (totalPages > 0) { showToastNotification(`${totalPages} bloc(s) pour l'Étape 3 ont été générés.`); }
        });

        function handleGenerateDetailedTextPromptForPage(event) {
            const pageNum = parseInt(event.target.dataset.page, 10);
            const titreEtDescriptionBD = step1AiResponse.value.trim();
            const descriptionDeChaquePage = step2AiResponse.value.trim(); 
            let unitName = getUnitName();

            if (!titreEtDescriptionBD) { showToastNotification("Veuillez coller le résultat de l'IA de l'Étape 1."); return; }
            if (!descriptionDeChaquePage) { showToastNotification("Veuillez coller le résultat de l'IA de l'Étape 2."); return; }
            
            let prevPageDescriptionRef = "";
            if (pageNum > 1) {
                const prevPageTextResponseTextarea = document.getElementById(`pageAiDetailedResponse_${pageNum - 1}`); 
                if (prevPageTextResponseTextarea && prevPageTextResponseTextarea.value.trim() !== "") {
                    prevPageDescriptionRef = `\nVoici la description détaillée du/de la ${unitName} précédente comme référence :\n--- DÉBUT DESCRIPTION ${unitName.toUpperCase()} PRÉCÉDENTE ---\n"${prevPageTextResponseTextarea.value.trim()}"\n--- FIN DESCRIPTION ${unitName.toUpperCase()} PRÉCÉDENTE ---`;
                } else { showToastNotification(`Info: La description textuelle détaillée de la ${unitName} ${pageNum - 1} n'a pas été fournie pour référence pour le prompt texte.`); }
            }

            const currentNomBd = nomBdInput.value;
            const totalPagesForGagCheck = parseInt(totalPagesInput.value, 10);
            let endingDescriptionDetail = "une conclusion satisfaisante (par exemple, la fin d'un arc narratif, la résolution d'un combat important, ou un cliffhanger pour le prochain chapitre/la prochaine histoire).";
            if (currentNomBd.toLowerCase().includes("gag") || totalPagesForGagCheck <= 2) {
                endingDescriptionDetail = `une "punch line" mémorable – un dénouement surprenant (à la dernière case seulement), très drôle, et d'une nature délicieusement absurde ou inusitée.`;
            }
            
            const prompt = `Considérant cette oeuvre (${getTypeOeuvre().replace("d'un ", "").replace("d'une ", "")}) suivante:
--- DÉBUT TITRE ET DESCRIPTION BD ---
${titreEtDescriptionBD}
--- FIN TITRE ET DESCRIPTION BD ---

Et la description sommaire de chaque ${unitName} (générée à l'étape précédente):
--- DÉBUT DESCRIPTION SOMMAIRE DES ${unitName.toUpperCase()}S ---
${descriptionDeChaquePage}
--- FIN DESCRIPTION SOMMAIRE DES ${unitName.toUpperCase()}S ---

Générez-moi la description détaillée TEXTUELLE du/de la ${unitName} ${pageNum}.${prevPageDescriptionRef}
La description détaillée doit contenir chaque case du/de la ${unitName} avec les dialogues (sauf si c'est un gag muet où les descriptions indiqueront 0 bulles/mots) et une description schématique simple des dessins. ${getMangaSpecifics()}
La description détaillée doit pouvoir servir de prompt pour un générateur d'images par intelligence artificielle.
Assurez-vous de respecter le ton, le style, les personnages définis et la structure du/de la ${unitName} (nombre de cases, etc.) qui ont été établis précédemment pour cette oeuvre.
Si la description sommaire des ${unitName}s (issue de l'étape 2) indique un effet intriguant pour ce(tte) ${unitName} ${pageNum} (et si ce n'est pas le/la dernier/dernière ${unitName} de l'oeuvre et qu'elle a plusieurs ${unitName}s), assurez-vous que la description détaillée du/de la ${unitName} se termine par cet effet.
Si c'est le/la dernier/dernière ${unitName} de l'oeuvre (selon les descriptions de l'étape 2), assurez ${endingDescriptionDetail}`;
            document.getElementById(`step3PagePromptOutput_${pageNum}`).value = prompt; 
            showToastNotification(`Prompt pour texte détaillé de la ${unitName} ${pageNum} généré.`);
        }

        function handleGenerateStoryboardPromptForPage(event, sourceTextareaIdForMonobloc, isFullMonoblocConversion = false) { 
            const pageNum = isFullMonoblocConversion ? 1 : parseInt(event.target.dataset.page, 10); 
            const detailedTextForPage = document.getElementById(sourceTextareaIdForMonobloc || `pageAiDetailedResponse_${pageNum}`).value.trim();
            const step1Info = step1AiResponse.value.trim();

            if (!detailedTextForPage) {
                showToastNotification(`Veuillez d'abord fournir la description textuelle détaillée pour ${isFullMonoblocConversion ? 'la sortie monobloc' : `la ${getUnitName()} ${pageNum}`}.`);
                return;
            }
            
            const nomDeLaBd = nomBdInput.value.trim() || "[Nom de BD non spécifié]";
            const panelsPerPage = panelsPerPageInput.value; 
            let unitName = getUnitName();
            let typeOeuvre = getTypeOeuvre();
            let mangaSpecificsForStoryboard = getMangaSpecifics();
            
            let extractedTitle = nomDeLaBd; 
            const titleFromStep1Match = step1Info.match(/TITRE DE L'OEUVRE\s*:\s*([^\n]+)/i);
            if (titleFromStep1Match && titleFromStep1Match[1]) {
                extractedTitle = titleFromStep1Match[1].trim();
            } else if (isFullMonoblocConversion && detailedTextForPage) {
                const monoblocTitleMatch = detailedTextForPage.match(/### PARTIE A : DÉFINITION GLOBALE DE L'OEUVRE[\s\S]*?1\.\s*TITRE DE L'OEUVRE\s*:\s*([^\n]+)/i);
                if (monoblocTitleMatch && monoblocTitleMatch[1]) {
                    extractedTitle = monoblocTitleMatch[1].trim();
                }
            }

            const storyboardPrompt = `
Vous êtes un assistant expert en création de storyboards VISUELS pour bandes dessinées au format HTML et SVG, à partir de descriptions textuelles détaillées.

TÂCHE : Convertir ${isFullMonoblocConversion ? `la description textuelle complète de l'oeuvre "${nomDeLaBd}" (type "${typeOeuvre}") fournie ci-dessous, qui peut décrire UNE ou PLUSIEURS ${unitName}s,` : `la description détaillée de la ${unitName} NUMÉRO ${pageNum} de l'oeuvre "${nomDeLaBd}" (type "${typeOeuvre}") fournie ci-dessous`} en un **DOCUMENT HTML COMPLET ET AUTONOME** contenant le storyboard pour ${isFullMonoblocConversion ? `TOUTES les ${unitName}s décrites` : `cette SEULE ${unitName}`}.

${isFullMonoblocConversion ? 
`DESCRIPTION COMPLÈTE DE L'OEUVRE À CONVERTIR (contient Titre global, Résumé global, Personnages, Ton, et la description détaillée de chaque ${unitName}) :` : 
`INFORMATIONS GÉNÉRALES SUR L'OEUVRE (issues de l'Étape 1 du processus par étapes, pour contexte et titre global) :`}
--- DÉBUT INFO OEUVRE / TEXTE SOURCE ---
${isFullMonoblocConversion ? detailedTextForPage : (step1Info || `TITRE DE L'OEUVRE : ${nomDeLaBd}\n[Autres informations de l'Étape 1 non fournies]`)} 
--- FIN INFO OEUVRE / TEXTE SOURCE ---

${isFullMonoblocConversion ? '' : 
`DESCRIPTION DÉTAILLÉE DE LA ${unitName.toUpperCase()} ${pageNum} À CONVERTIR :
--- DÉBUT DESCRIPTION ${unitName.toUpperCase()} ${pageNum} ---
${detailedTextForPage}
--- FIN DESCRIPTION ${unitName.toUpperCase()} ${pageNum} ---`}

PARAMÈTRES GÉNÉRAUX DE L'OEUVRE (pour contexte, la description détaillée est prioritaire pour le contenu de chaque ${unitName}) :
- Nom de l'oeuvre / Série : ${nomDeLaBd}
- Cases par ${unitName} (moyenne indicative globale, la description détaillée de chaque ${unitName} doit être suivie pour le nombre exact de cases) : ${panelsPerPage}

INSTRUCTIONS POUR LA GÉNÉRATION DU DOCUMENT HTML/SVG :
1.  **Format de Sortie :** Un document HTML5 valide et complet, commençant par \`<!DOCTYPE html>\` et se terminant par \`</html>\`.
2.  **Extraction d'Informations Clés :**
    * Extrayez le **TITRE GÉNÉRAL DE L'OEUVRE** (cherchez "TITRE DE L'OEUVRE :" dans la description fournie). Si non trouvé, utilisez "${extractedTitle}".
    * Pour ${isFullMonoblocConversion ? `CHAQUE ${unitName.toUpperCase()} décrite dans le texte source (PARTIE B et C)` : `CETTE ${unitName.toUpperCase()} ${pageNum}`}:
        * Synthétisez un **Résumé Sommaire EXTRÊMEMENT DENSE** (1 phrase courte max, enlevez les articles et mots superflus si besoin pour une concision maximale) de cette ${unitName}, contenant TOUTE l'information essentielle pour la comprendre, à partir de sa description détaillée.
        * Déterminez le **Nombre de cases** pour cette ${unitName} en analysant sa description (PARTIE B ou C de la source).
3.  **Structure du Document HTML :**
    * \`<head>\` avec \`<title>Storyboard - [TITRE DE L'OEUVRE] ${isFullMonoblocConversion ? '(Complet)' : `- ${unitName.charAt(0).toUpperCase() + unitName.slice(1)} ${pageNum}`}</title>\` et les styles CSS.
    * \`<body>\` avec \`<h1>[TITRE DE L'OEUVRE] ${isFullMonoblocConversion ? '(Storyboard Complet)' : `- ${unitName.charAt(0).toUpperCase() + unitName.slice(1)} ${pageNum}`}</h1>\`.
    * Pour ${isFullMonoblocConversion ? `CHAQUE ${unitName.toUpperCase()} identifiée dans le texte source (numérotez-les séquentiellement)`: `la ${unitName.toUpperCase()} unique demandée (identifiée comme ${pageNum})`} :
        * Un \`<div class="comic-page" id="page_[NuméroEffectifDeLaPage]_storyboard_content">\`.
        * Dans ce div, le résumé dense de la ${unitName} (\`<h5>\`) et une \`<div class="panel-grid">\`.
4.  **Structure par Case :**
    * Chaque case décrite devient un \`<div class="panel-container">\`.
    * Titre \`<h6>\` : "[LA DESCRIPTION VISUELLE DÉTAILLÉE DE LA CASE (extraite du texte source), SANS les dialogues. Formatée pour lisibilité, mais sans labels techniques comme 'Description Visuelle :']".
    * Élément \`<svg class="panel-svg" viewBox="0 0 300 200" xmlns="http://www.w3.org/2000/svg">\`.
5.  **Contenu SVG Schématique :**
    * Pour chaque case, basez le dessin SVG sur sa "Description Visuelle" COMPLÈTE extraite du texte source (celle utilisée pour le \`<h6>\` ci-dessus), en veillant à ce qu'elle ne contienne PAS les dialogues.
    * Dialogues/Narration : Extrayez les "Dialogues/Texte" de chaque case du texte source et intégrez-les dans des bulles/rectangles SVG distincts. Chaque bulle/bloc doit contenir un sous-élément SVG \`<title>texte COMPLET du dialogue/narration</title>\` pour tooltip (apparaîtra au survol, le délai est géré par le navigateur).
    * ${mangaSpecificsForStoryboard}
6.  **Code Source Brut :** N'ÉCHAPPEZ PAS les caractères HTML (\`<\`, \`>\`).

UTILISEZ LE TEMPLATE HTML/SVG SUIVANT COMME STRUCTURE DE BASE POUR VOTRE SORTIE :
\`\`\`html
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Storyboard - [TITRE DE L'OEUVRE EXTRAIT]${isFullMonoblocConversion ? ' - Complet' : ` - ${unitName.charAt(0).toUpperCase() + unitName.slice(1)} ${pageNum}`}</title>
    <style>
        body { font-family: sans-serif; margin: 10px; background-color: #e9e9e9; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .comic-page { border: 2px solid #999; padding: 15px; background-color: #fff; box-shadow: 3px 3px 5px #ccc; width: 90%; margin: 20px auto; }
        .comic-page-summary { font-style: italic; margin-bottom: 15px; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        .panel-grid { display: flex; flex-wrap: wrap; gap: 10px; }
        .panel-container { border: 1px solid #ccc; margin-bottom: 15px; padding: 10px; background-color: #f9f9f9; flex: 1 1 calc(33.333% - 20px); box-sizing: border-box; min-width: 450px; max-width: 500px; display: flex; flex-direction: column;}
        .panel-summary { font-size: 0.9em; color: #333; margin-bottom: 5px; white-space: pre-wrap; }
        .panel-svg { border: 1px solid black; width: 100%; height: auto; aspect-ratio: 4/3; background-color: white; }
        svg text { font-family: "Comic Sans MS", "Arial Narrow", sans-serif; } 
        .speech-bubble-group title {} 
        .speech-bubble-path { fill: white; stroke: black; stroke-width: 1.5; }
        .speech-bubble-text { text-anchor: middle; dominant-baseline: middle; font-size: 14px; fill: black; }
        .narrative-box-path { fill: #FFFACD; stroke: #F0E68C; stroke-width: 1; }
        .narrative-text { font-size: 15px; font-style: italic; fill: black; }
        h6 { font-weight: normal; font-size: 14px; }
    </style>
</head>
<body>
    <h1>[TITRE DE L'OEUVRE EXTRAIT]${isFullMonoblocConversion ? ` (Storyboard Complet)` : ` - ${unitName.charAt(0).toUpperCase() + unitName.slice(1)} ${pageNum}`}</h1>
    
    <div class="comic-page" id="page_X_storyboard_content"> 
        <h5>${unitName.charAt(0).toUpperCase() + unitName.slice(1)} X : [Résumé EXTRÊMEMENT DENSE de cette ${unitName}]</h5>
        <div class="panel-grid">
            <div class="panel-container" id="page_X_panel_Y"> 
                <h6>[LA DESCRIPTION VISUELLE DÉTAILLÉE DE LA CASE (provenant du texte source, SANS les dialogues, et sans labels comme "Description Visuelle:")]</h6>
                <svg class="panel-svg" viewBox="0 0 300 200" xmlns="http://www.w3.org/2000/svg">
                    [Contenu SVG pour cette case. Les DIALOGUES/TEXTES (extraits du texte source) vont dans les bulles SVG, avec <title> pour tooltip.]
                    ${mangaSpecificsForStoryboard}
                </svg>
            </div>
        </div>
    </div>
</body>
</html>
\`\`\`
${isFullMonoblocConversion ? `
INSTRUCTION IMPORTANTE CONCERNANT LA LONGUEUR DE LA RÉPONSE (Mode Monobloc vers Storyboard) :
Si le storyboard HTML/SVG complet pour TOUTES les ${unitName}s décrites dans le texte source est trop long pour une seule réponse :
1.  Veuillez générer autant de ${unitName}s complètes que possible DANS UN DOCUMENT HTML VALIDE.
2.  Indiquez clairement à la fin de votre réponse jusqu'à quelle ${unitName} le code a été fourni (ex: "Code HTML/SVG fourni jusqu'à la ${unitName} X sur Y.").
3.  Soyez prêt à continuer la génération du code pour les ${unitName}s suivantes si l'utilisateur envoie simplement le message : "Continuez". Vous reprendrez alors exactement où vous vous êtes arrêté, en générant les ${unitName}s suivantes, idéalement en complétant le document HTML (si possible) ou en démarrant un nouveau fragment HTML pour les ${unitName}s restantes.` : ''}
`;
            const outputTextareaId = isFullMonoblocConversion ? `monoblocToStoryboardConversionPromptOutput` : `storyboardPromptOutput_page_${pageNum}`;
            document.getElementById(outputTextareaId).value = storyboardPrompt.trim();
            showToastNotification(`Prompt Storyboard pour ${isFullMonoblocConversion ? 'la sortie monobloc' : unitName + ' ' + pageNum} généré.`);
        }
        
        compileAllContentBtn.addEventListener('click', function() {
            let fullCompilation = [];
            const totalPages = parseInt(totalPagesInput.value, 10); 
            let unitName = getUnitName().toUpperCase();

            const etape1Content = step1AiResponse.value.trim();
            if (etape1Content) { fullCompilation.push("=== ÉTAPE 1 : DÉFINITION DE L'OEUVRE ==="); fullCompilation.push(etape1Content);
            } else { showToastNotification("Contenu de l'Étape 1 manquant pour la compilation."); }

            const etape2Content = step2AiResponse.value.trim();
            if (etape2Content) { fullCompilation.push(`\n\n=== ÉTAPE 2 : STRUCTURE DES ${unitName}S (DESCRIPTIONS SOMMAIRES) ===`); fullCompilation.push(etape2Content);
            } else { showToastNotification("Contenu de l'Étape 2 manquant pour la compilation."); }
            
            if (!isNaN(totalPages) && totalPages > 0) {
                let allPagesDetailCollectedOrMarked = true; 
                let step3Content = [];
                for (let i = 1; i <= totalPages; i++) {
                    const pageDetailTextarea = document.getElementById(`pageAiDetailedResponse_${i}`);
                    if (pageDetailTextarea) { 
                        if (pageDetailTextarea.value.trim()) {
                            step3Content.push(`\n--- ${unitName} ${i} ---`); step3Content.push(pageDetailTextarea.value.trim());
                        } else {
                            step3Content.push(`\n--- ${unitName} ${i} ---`); step3Content.push(`[Description détaillée pour ce(tte) ${unitName.toLowerCase()} non fournie]`);
                            allPagesDetailCollectedOrMarked = false; 
                        }
                    } else { 
                        step3Content.push(`\n--- ${unitName} ${i} ---`); step3Content.push(`[Champs pour ${unitName.toLowerCase()} ${i} non générés/trouvés]`);
                        allPagesDetailCollectedOrMarked = false;
                    }
                }
                if (step3Content.length > 0){ fullCompilation.push(`\n\n=== ÉTAPE 3 : DESCRIPTIONS DÉTAILLÉES DES ${unitName}S ===`); fullCompilation.push(step3Content.join("\n")); 
                } else if (totalPages > 0) { 
                     fullCompilation.push(`\n\n=== ÉTAPE 3 : DESCRIPTIONS DÉTAILLÉES DES ${unitName}S ===`);
                     fullCompilation.push(`[Aucune description détaillée de ${unitName.toLowerCase()} n'a été fournie pour les ${totalPages} ${unitName.toLowerCase()}(s) de base.]`);
                }
                 if (!allPagesDetailCollectedOrMarked && step3Content.length > 0) { 
                    showToastNotification(`Certaines descriptions détaillées de ${unitName.toLowerCase()} de l'Étape 3 sont manquantes ou non générées.`);
                }
            } else { showToastNotification("Nombre de pages (base) non défini ou invalide pour compiler l'Étape 3."); }
            
            finalCompilationOutput.value = fullCompilation.join("\n"); 
            if(fullCompilation.length > 0 && (etape1Content || etape2Content || (!isNaN(totalPages) && totalPages > 0) ) ) {
                showToastNotification("Compilation textuelle terminée !");
            } else { showToastNotification("Rien à compiler pour le moment."); }
        });
        copyFinalCompilationBtn.addEventListener('click', () => {
            if (finalCompilationOutput.value.trim() === "") { showToastNotification("Rien à copier, la compilation est vide."); return; }
            copyToClipboard('finalCompilationOutput');
        });
        
        generateSingleBlockTextPromptBtn.addEventListener('click', function() {
            const nomDeLaBd = nomBdInput.value.trim() || "[À DÉFINIR PAR L'IA]";
            const totalPages = parseInt(totalPagesInput.value, 10);
            const variation = parseInt(pageVariationInput.value, 10);
            const panelsPerPage = panelsPerPageInput.value;
            const bubblesPerPage = bubblesPerPageInput.value;
            const wordsPerPage = wordsPerPageInput.value;
            const yellowBlocksPerPage = yellowBlocksPerPageInput.value;

            if (isNaN(totalPages) || totalPages <= 0) {
                showToastNotification("Veuillez définir un nombre de pages (base) valide pour le prompt unique.");
                return;
            }

            let typeOeuvre = getTypeOeuvre(); 
            let unitName = getUnitName();   

            let pageCountDetails = "";
            if (variation === 0) {
                pageCountDetails = `${totalPages} ${unitName}${totalPages > 1 ? 's' : ''} (nombre fixe).`;
            } else {
                const minPages = Math.max(1, totalPages - variation);
                const maxPages = totalPages + variation;
                pageCountDetails = `environ ${totalPages} ${unitName}${totalPages > 1 ? 's' : ''}, pouvant varier de ${minPages} à ${maxPages}.`;
            }

            let endingType = "une conclusion satisfaisante (par exemple, la fin d'un arc narratif, la résolution d'un combat important, ou un cliffhanger pour le prochain chapitre/la prochaine histoire).";
            if (nomDeLaBd.toLowerCase().includes("gag") || totalPages <= 2) {
                endingType = `une "punch line" (à la dernière case seulement) – un dénouement surprenant, très drôle, et d'une nature délicieusement absurde ou inusitée.`;
            }
            
            let mangaSpecifics = getMangaSpecifics();

            const globalPrompt = `
Vous êtes un assistant expert en création de scénarios et de storyboards pour bandes dessinées.
Votre tâche est de générer une oeuvre complète de type "${typeOeuvre}" dans l'univers de "${nomDeLaBd}".

PARAMÈTRES GÉNÉRAUX DE L'OEUVRE FOURNIS À TITRE INDICATIF (L'IA DEVRA DÉFINIR LES SPÉCIFICITÉS PAR ${unitName.toUpperCase()} DANS LA PARTIE B ET S'Y TENIR) :
- Longueur de base attendue : ${totalPages} ${unitName}${totalPages > 1 ? 's' : ''}.
- Variation autorisée : +/- ${variation} ${unitName}${totalPages > 1 ? 's' : ''}. (Le nombre total de ${unitName}s de l'oeuvre générée doit se situer dans cette fourchette).
- Cases par ${unitName} (moyenne indicative globale) : ${panelsPerPage}
- Bulles par ${unitName} (moyenne indicative globale) : ${bubblesPerPage}
- Mots par ${unitName} (moyenne indicative globale) : ${wordsPerPage}
- Blocs narratifs/explicatifs par ${unitName} (moyenne indicative globale) : ${yellowBlocksPerPage}

VEUILLEZ FOURNIR LES INFORMATIONS SUIVANTES DANS L'ORDRE ET AVEC LA STRUCTURE DÉTAILLÉE CI-DESSOUS :

### PARTIE A : DÉFINITION GLOBALE DE L'OEUVRE
1.  **TITRE DE L'OEUVRE :**
    [Proposez un titre original et adapté]
2.  **RÉSUMÉ DE L'INTRIGUE PRINCIPALE :**
    (1-2 phrases pour un gag/strip, 3-5 pour une histoire courte ou un chapitre, potentiellement plus pour un arc narratif ou une aventure complète. Décrivez le concept central, les enjeux et la direction générale de l'intrigue.)
3.  **PERSONNAGES IMPORTANTS :**
    (Listez les personnages clés de cette oeuvre spécifique, y compris les nouveaux si pertinent, et décrivez brièvement leur rôle ou leur objectif dans cette intrigue.)
4.  **TON ET STYLE :**
    (Décrivez le ton général (humoristique, aventureux, dramatique, etc.) et le style graphique/narratif à adopter pour cette oeuvre, en respectant l'univers de "${nomDeLaBd}".)
5.  **ORIGINALITÉ ET RESPECT DE L'UNIVERS :**
    L'oeuvre générée doit être une création originale, évitant de reproduire trop fidèlement des oeuvres existantes, le titre ne doit pas ressembler à un titre existant de l'oeuvre, tout en restant cohérente avec l'esprit, les thèmes et les personnages de l'univers de "${nomDeLaBd}".

### PARTIE B : STRUCTURE DÉTAILLÉE ET RÉSUMÉS DES ${unitName.toUpperCase()}S
1.  **NOMBRE TOTAL DE ${unitName.toUpperCase()}S EFFECTIVEMENT UTILISÉES DANS VOTRE GÉNÉRATION :**
    [Indiquez ici le nombre exact de ${unitName}s que vous allez décrire ci-dessous, en respectant la variation autorisée autour de ${totalPages} ${unitName}s.]
2.  **POUR CHAQUE ${unitName.toUpperCase()}** (du/de la ${unitName} 1 au/à la ${unitName} [Nombre total de ${unitName}s utilisées]) :

    **${unitName.charAt(0).toUpperCase() + unitName.slice(1)} [Numéro]**
    * **Résumé Sommaire :** (1-3 lignes maximum. Décrivez l'action principale et le contenu essentiel. Assurez un effet intriguant à la fin (sauf la dernière, ou pour un gag en une seule unité) qui donne envie de lire la suite, et dont la mini-intrigue sera résolue ensuite.)
    * **Spécifications pour CETTE UNITÉ (${unitName.toUpperCase()}) :** (Ces valeurs doivent être respectées dans la PARTIE C)
        * Nombre de cases prévues : [Nombre exact]
        * Nombre de bulles prévues (approximatif) : [Nombre]
        * Nombre de mots prévus (approximatif) : [Nombre]
        * Nombre de blocs narratifs/explicatifs prévus : [Nombre]

    *(Rappel : La dernière unité (${unitName}) doit se terminer (dernière case seulement) par ${endingType})*

### PARTIE C : DESCRIPTION DÉTAILLÉE DE CHAQUE ${unitName.toUpperCase()} ET DE CHAQUE CASE
**POUR CHAQUE ${unitName.toUpperCase()}** (décrite dans la PARTIE B, du/de la ${unitName} 1 au/à la ${unitName} [Nombre total de ${unitName}s utilisées]) :

**-------------------- DÉBUT ${unitName.toUpperCase()} [Numéro] --------------------**
*(Rappel du Résumé Sommaire de la ${unitName.toUpperCase()} [Numéro] ici)*

**POUR CHAQUE CASE** (de 1 au nombre de cases défini pour CETTE UNITÉ (${unitName.toUpperCase()}) DANS LA PARTIE B) :

**Case [Numéro de la case] :**
* **Description Visuelle :** (Description schématique simple et claire du dessin : personnages, actions, expressions, décor, cadrage, angles. ${mangaSpecifics})
* **Dialogues/Texte :** (Texte exact des bulles, pensées, ou blocs narratifs DANS cette case. Si muet, indiquer "Aucun dialogue".)

**-------------------- FIN ${unitName.toUpperCase()} [Numéro] --------------------**

NOTES IMPORTANTES POUR VOTRE GÉNÉRATION :
-   **Cohérence et Continuité :** Assurez une parfaite continuité narrative, logique et visuelle.
-   **Respect des Instructions :** Suivez scrupuleusement le ton, le style, les personnages de l'univers "${nomDeLaBd}", ainsi que les paramètres généraux (moyennes indicatives globales) ET SURTOUT les spécifications (nombre de cases, bulles, mots, blocs narratifs) que VOUS AVEZ DÉFINIES pour chaque ${unitName} dans la PARTIE B lors de la génération de la PARTIE C.
-   **Clarté pour Générateur d'Images :** La "Description Visuelle" de chaque case doit être formulée de manière à pouvoir servir de prompt efficace pour un générateur d'images par IA.
-   **Format de Sortie :** Veuillez utiliser la structure de titres et listes (comme "### PARTIE A", "1. TITRE", "**${unitName.charAt(0).toUpperCase() + unitName.slice(1)} [X]**", "**Case [Y] :**") pour faciliter la lecture de votre réponse.

INSTRUCTION IMPORTANTE CONCERNANT LA LONGUEUR DE LA RÉPONSE POUR LA PARTIE C :
La description détaillée de toutes les ${unitName}s (PARTIE C) peut s'avérer très longue, en particulier pour les œuvres comptant de nombreuses ${unitName}s.
Si vous ne parvenez pas à générer l'intégralité de la PARTIE C en une seule réponse en raison de limitations de longueur :
1.  Veuillez générer autant de ${unitName}s complètes que possible dans votre réponse actuelle.
2.  À la fin de votre réponse, veuillez indiquer clairement jusqu'à quelle ${unitName} vous avez fourni la description détaillée (par exemple : "Description détaillée fournie jusqu'à la ${unitName} X sur Y.").
3.  Soyez prêt à continuer la génération des ${unitName}s suivantes si l'utilisateur vous envoie simplement le message : "Continuez". Vous reprendrez alors exactement où vous vous êtes arrêté.
`;
            singleBlockTextPromptOutput.value = globalPrompt.trim();
            showToastNotification("Prompt unique global (texte) généré !");
        });
        copySingleBlockTextPromptBtn.addEventListener('click', () => copyToClipboard('singleBlockTextPromptOutput'));
        
        // NOUVEAU : Écouteur pour le bouton de génération de prompt roman
        generateSingleBlockRomanPromptBtn.addEventListener('click', function() {
            const nomDeLaBd = nomBdInput.value.trim() || "[Nom de l'Oeuvre à Définir]";
            const totalPages = parseInt(totalPagesInput.value, 10); // Interprété comme chapitres/sections
            const variation = parseInt(pageVariationInput.value, 10);
            // panelsPerPage et bubblesPerPage sont moins pertinents pour le format roman direct
            const wordsPerPage = wordsPerPageInput.value; // Interprété comme mots par chapitre/section
            const yellowBlocksPerPage = yellowBlocksPerPageInput.value; // Interprété comme importance de la narration

            if (isNaN(totalPages) || totalPages <= 0) {
                showToastNotification("Veuillez définir un nombre de chapitres/sections (base) valide.");
                return;
            }

            let typeOeuvreRoman = getTypeOeuvre(true); // true pour format roman
            let unitNameRoman = getUnitName(true);     // Sera "chapitre"

            let pageCountDetails = "";
            if (variation === 0) {
                pageCountDetails = `${totalPages} ${unitNameRoman}${totalPages > 1 ? 's' : ''} au total (nombre fixe).`;
            } else {
                const minPages = Math.max(1, totalPages - variation);
                const maxPages = totalPages + variation;
                pageCountDetails = `Environ ${totalPages} ${unitNameRoman}${totalPages > 1 ? 's' : ''} au total. Le nombre final peut varier de ${minPages} à ${maxPages}.`;
            }
            
            const romanPrompt = `
Vous êtes un assistant expert en création littéraire.
Votre tâche est de générer une oeuvre narrative complète de type "${typeOeuvreRoman}" dans l'univers de "${nomDeLaBd}", au format d'un roman ou d'une nouvelle.

PARAMÈTRES GÉNÉRAUX DE L'OEUVRE (pour guider la structure et la densité) :
- Longueur de base attendue : ${totalPages} ${unitNameRoman}${totalPages > 1 ? 's' : ''}.
- Variation autorisée : +/- ${variation} ${unitNameRoman}${totalPages > 1 ? 's' : ''}.
- Mots par ${unitNameRoman} (moyenne indicative) : ${wordsPerPage}
- Importance de la Narration vs Dialogue (0=très dialogué, 1=équilibré, 2=très narratif) : ${yellowBlocksPerPage} 
  (Adaptez la proportion de descriptions narratives par rapport aux dialogues en conséquence.)

VEUILLEZ FOURNIR LES INFORMATIONS SUIVANTES DANS L'ORDRE ET AVEC LA STRUCTURE DÉTAILLÉE CI-DESSOUS :

### PARTIE A : DÉFINITION GLOBALE DE L'OEUVRE
1.  **TITRE DE L'OEUVRE :**
    [Proposez un titre original et adapté]
2.  **RÉSUMÉ DE L'INTRIGUE PRINCIPALE :**
    (Décrivez le concept central, les enjeux majeurs, et la direction générale de l'intrigue en 3 à 7 phrases.)
3.  **PERSONNAGES IMPORTANTS :**
    (Listez les personnages clés, y compris les nouveaux si pertinent, et décrivez brièvement leur rôle, motivations, et arcs narratifs potentiels.)
4.  **TON ET STYLE D'ÉCRITURE :**
    (Décrivez le ton général (humoristique, dramatique, épique, etc.) et le style d'écriture (ex: direct, poétique, introspectif) à adopter pour cette oeuvre, en respectant l'univers de "${nomDeLaBd}" mais adapté au format roman.)
5.  **THÈMES ABORDÉS :**
    [Quels thèmes majeurs seront explorés dans cette histoire ?]
6.  **ORIGINALITÉ ET RESPECT DE L'UNIVERS :**
    L'oeuvre générée doit être une création originale, tout en restant cohérente avec l'esprit et les personnages de l'univers de "${nomDeLaBd}".

### PARTIE B : STRUCTURE DES ${unitNameRoman.toUpperCase()}S / SECTIONS
1.  **NOMBRE TOTAL DE ${unitNameRoman.toUpperCase()}S EFFECTIVEMENT UTILISÉES DANS VOTRE GÉNÉRATION :**
    [Indiquez ici le nombre exact de ${unitNameRoman}s que vous allez décrire ci-dessous, en respectant la variation autorisée.]
2.  **POUR CHAQUE ${unitNameRoman.toUpperCase()}** (de 1 au Nombre total de ${unitNameRoman}s) :

    **${unitNameRoman.charAt(0).toUpperCase() + unitNameRoman.slice(1)} [Numéro] - Titre du ${unitNameRoman} (optionnel) :** [Si vous souhaitez un titre pour ce ${unitNameRoman}]
    * **Résumé Sommaire du ${unitNameRoman.toUpperCase()} :** (2-4 lignes maximum. Décrivez les événements clés, le développement de l'intrigue ou des personnages dans ce ${unitNameRoman}. Assurez que chaque ${unitNameRoman} (sauf le dernier) se termine d'une manière qui engage le lecteur pour le suivant.)

    *(Rappel : Le dernier ${unitNameRoman} doit offrir une conclusion satisfaisante et cohérente avec l'ensemble de l'oeuvre.)*

### PARTIE C : CORPS DU RÉCIT (FORMAT ROMAN)

**POUR CHAQUE ${unitNameRoman.toUpperCase()}** (défini en PARTIE B, de 1 au Nombre total de ${unitNameRoman}s) :

**-------------------- DÉBUT ${unitNameRoman.toUpperCase()} [Numéro] --------------------**
**(Si vous avez donné un titre au ${unitNameRoman} en PARTIE B, vous pouvez le répéter ici. Sinon, commencez directement par le texte.)**
*(Rappel du Résumé Sommaire du ${unitNameRoman.toUpperCase()} [Numéro] ici, pour guider votre écriture)*

[Écrivez ici le contenu de ce ${unitNameRoman} sous forme de prose narrative.
- Intégrez naturellement les descriptions d'actions, d'environnements, les émotions et les pensées des personnages.
- Pour les dialogues, utilisez IMPÉRATIVEMENT le format suivant pour chaque prise de parole :
  - PERSONNAGE (optionnel : adverbe ou courte description de ton/action) : "Texte du dialogue entre guillemets."
  Exemple : - Haddock (surpris) : "Mille millions de mille sabords !"
- Gérez les changements de scènes ou de points de vue avec des sauts de paragraphe ou des séparateurs discrets si nécessaire.
- L'ensemble doit se lire comme un ${unitNameRoman} de roman ou une nouvelle, en respectant le ton, le style et les personnages définis en PARTIE A, et en s'inspirant des paramètres de densité (mots par ${unitNameRoman}) et d'importance de la narration.]

**-------------------- FIN ${unitNameRoman.toUpperCase()} [Numéro] --------------------**

NOTES IMPORTANTES POUR VOTRE GÉNÉRATION :
-   **Cohérence Narrative :** Assurez une parfaite continuité et progression logique de l'intrigue et des personnages à travers les ${unitNameRoman}s.
-   **Style d'Écriture :** Maintenez un style d'écriture engageant et adapté au public cible de l'univers "${nomDeLaBd}".
-   **Format de Sortie :** Veuillez utiliser la structure de titres (### PARTIE A, etc.) et la mise en forme des dialogues comme indiqué pour faciliter la lecture.

INSTRUCTION IMPORTANTE CONCERNANT LA LONGUEUR DE LA RÉPONSE POUR LA PARTIE C :
La rédaction de tous les ${unitNameRoman}s (PARTIE C) peut s'avérer très longue.
Si vous ne parvenez pas à générer l'intégralité de la PARTIE C en une seule réponse en raison de limitations de longueur :
1.  Veuillez générer autant de ${unitNameRoman}s complets que possible dans votre réponse actuelle.
2.  À la fin de votre réponse, veuillez indiquer clairement jusqu'à quel ${unitNameRoman} vous avez fourni le texte (par exemple : "${unitNameRoman.charAt(0).toUpperCase() + unitNameRoman.slice(1)} X sur Y généré.").
3.  Soyez prêt à continuer la génération des ${unitNameRoman}s suivants si l'utilisateur vous envoie simplement le message : "Continuez". Vous reprendrez alors exactement où vous vous êtes arrêté.
`;
            singleBlockRomanPromptOutput.value = romanPrompt.trim();
            showToastNotification("Prompt Monobloc (Format Roman) généré !");
        });
        copySingleBlockRomanPromptBtn.addEventListener('click', () => copyToClipboard('singleBlockRomanPromptOutput'));


        generateMonoblocToStoryboardPromptBtn.addEventListener('click', function() {
            handleGenerateStoryboardPromptForPage(null, 'singleBlockAiTextOutput', true); 
        });
        copyMonoblocToStoryboardConversionPromptBtn.addEventListener('click', () => copyToClipboard('monoblocToStoryboardConversionPromptOutput'));
        
        document.addEventListener('DOMContentLoaded', function() {
            populatePresetDropdown(); 
            setDefaultParameters(); 
            switchMode('stepByStep'); 
            monoblocStoryboardConversionSection.classList.remove('hidden'); 
        });

    </script>
</body>
</html>